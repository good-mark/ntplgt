1   ...   13   14   15   16   17   18   19   20   ...   37 Листинг 7.11. Трехмерный астероид (AFIELD.С). // ВКЛЮЧАЕМЫЕ ФАЙЛЫ //////////////////////////////////////// #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include "graph0.h" // включаем нашу графическую библиотеку // ОПРЕДЕЛЕНИЯ///////////////////////////////////////////// #define NUM_STARS 30 // СТРУКТУРЫ /////////////////////////////////////////////// typedef struct star_typ { int x,y; // позиция звезды int vel; // скорость звезды по координате х int color; // цвет звезды} star,*star_ptr; // ГЛОБАЛЬНЫЕ ПЕРЕМЕННЫЕ /////////////////////////////////// star stars[NUM_STARS]; // звездное полеsprite object; pcx_picture ast_cells; // функции ///////////////////////////////////////////void Star_Field(void) { static int star_first=1; // Эта функция создает трехмерное звездное поле int index; // проверяем, следует ли нам создать звездное поле, //то есть первый ли раз вызвана функция if (star_first) { // обнуляем флаг первого вызоваstar_first=0; // инициализируем все звезды for (index=0; index { // инициализируем для каждой звезды позицию, скорость и цвет stars[index].х = rand()%320; stars[index].у = rand()%180; // определяем плоскость звезды switch(rand()%3){ case 0: // плоскость 1 - самая далекая {  // установка скорости и цвета stars[index].vel = 2; stars[index].color.= 8; } break; case 1: // плоскость 2 - среднее расстояние{stars[index].vel = 4;stars[index].color = 7;) break; case 2://плоскость 3 - самая близкая{stars[index].vel = 6;stars[index].color = 15;} break; } // конец оператора switch } // конец цикла //конец оператора if else  { // это не первый вызов, поэтому делаем рутинную работу -  // стираем, двигаем, рисуем   for (index=0; index {   if ((stars[index].x+=stars[index].vel) >=320 ) stars[index].x = 0; // рисуем Plot_Pixel_Fast_D(stars[index].x,stars[index].y, stars[index].color);  } // конец цикла } // конец оператора else } // конец Star_Field  ////////////////////////////////////////////////////////////void Scale_Sprite(sprite_ptr sprite,float scale)  { // эта функция масштабирует спрайт, рассчитывая число дублирования // исходных пикселей, необходимое для получения требуемого размера char far *work_sprite; int work_offset=0,offset,x,у; unsigned char data;  float y_scale_index,x_scale_step,y_scale_step,x_scale_index; // берем первый пиксель исходного изображения y_scale_index = 0; // рассчитываем дробный шаг y_scale_step = sprite_height/scale; x_scale_step = sprite_width /scale; // для простоты даем указателю на спрайт новое имяwork_sprite = sprite->frames[sprite->curr_frame]; // расчет смещения спрайта в видеобуфере offset = (sprite->y y x; // построчно масштабируем спрайт for (у=0; y  { // копируем следующую строчку в буфер экранаx_scale_index=0;for (x=0; x  { // проверка на прозрачность пикселя //(то есть равен ли он 0), если нет - прорисовываем пиксель if ((data=work_sprite[work_offset+(int)x_scale_index])) double_buffer[offset+x] = data; x_scale_index+=(x_scale_step) ; } // конец цикла по X //используя дробный шаг приращения определяем // следующий пиксель исходного изображенияу_scale_index+=y_scale_step; // переходим к следующей строке видеобуфера //и растрового буфера спрайта offset += SCREEN_WIDTH;work_offset = sprite_width*(int)(y_scale_index) ; } // конец цикла по Y } // конец Scale Sprite //////////////////////////////////////////////////////////// void Clear_Double_Buffer(void) { // эта функция очищает дублирующий буфер  // несколько грубо, зато работает _fmemset(double_buffer, 0, SCREEN_WIDTH * SCREEN_HEIGHT + 1); } // конец Clear_Double_Buffer // ОСНОВНАЯ ПРОГРАММА /////////////////////////////////////// void main(void){ int index, done=0,dx=5,dy=4,ds=4;float scale=5; // установка видеорежима 320х200х256 Set_Mode(VGA256) ; // установка размера спрайта sprite_width = sprite_height = 47; // инициализация файла PCX, который содержит // мультипликационные кадры PCX_Init((pcx_picture_ptr)&ast_cells) ; // загрузка файла PCX, который содержит мультипликационные кадры PCX_Load("asteroid.рсх", (pcx_picture_ptr)&ast_cells,1) ; // резервируем память под дублирующий буфер Init_Double_Buffer() ;Sprite_Init((sprite_ptr)&object,0,0,0,0,0,0) ; // загрузка кадров вращающегося астероида PCX_Grap_Bitmap((pcx_picture_ptr)&ast_cells, (sprite_ptr)&object,0,0,0); PCX_Grap_Bitmap ((pcx_picture_ptr) &ast_cells, (sprite_ptr)&object,1,1,0} ; PCX_Grap_Bitmap((pcx_picture_ptr)&ast_cells, (sprite_ptr)&object,2,2,0) ; PCX_Grap_Bitmap((pcx_picture_ptr)&ast_cells, (sprite_ptr)&object,3,3,0) ; PCX_Grap_Bitmap ((pcx_picture_ptr) &ast_cells, (sprite_ptr)&object,4,4,0); PCX_Grap_Bitmap((pcx_picture_ptr)&ast_cells, (sprite_ptr)&object,5,5,0) ; PCX_Grap_Bitmap((pcx_picture_ptr)&ast_cells, (sprite_ptr)&object,6,0,1); PCX_Grap_Bitmap({pcx_picture_ptr)&ast_cells, (sprite_ptr)&object,1,1,1) ; // позиционирование объекта в центре экрана object.curr_frame =0;object.x = 160-(sprite width>>1);object.у = 100-(sprite_height>>1) ; // очистка дублирующего буфера Clear_Double_Buffer(); // вывол масштабированного спрайта Scale_Sprite((sprite_ptr)&object,scale) ; Show_Double_Buffer(double_buffer) ; // главный циклwhile (!kbhit()) { // масштабируем астероидscale+=ds; // не слишком ли велик или мал астероид?if (scale>100 |1 scale  {ds=-ds;scale+=ds;} // конец if // перемещаем астероидobject.x+=dx;object.y+=dy; // коснулся ли астероид края экрана?if ((object.x + scale) > 310 || object.x  {dx=-dx;object.x+=dx;} // конец ifif ((object.у + scale) > 190 || object.у  dy=-dy;object.y+=dy;} // конец if // поворот астероида на 45 градусовif (++object.curr_frame==8) object.curr_frame=0; // очистка дублирующего буфераClear_Double_Buffer(); // прорисовка звездStar_Field() ; // масштабируем спрайт и выводим его в дублирующий буферScale_Sprite((sprite_ptr)&object,scale) ; // выводим дублирующий буфер на экранShow_Double_Buffer (double_buffer);} // конец оператора while// удаляем файл PCXPCX_Delete ((pcx_picture_ptr) &ast_cells); // возврат в текстовый режим Set_Mode (TEXT_MODE) ; } // конец функции main ИтогВ этой главе мы затронули много тем, относящихся к серьезной работе с растровой графикой и специальными визуальными эффектами, но, самое главное, мы впервые в этой книге начали разговор о том, как сделать так, чтобы игрок получил от вашей игры удовольствие. Я думаю, многие программисты уже забыли, что это такое, променяв его на мегабайты оцифрованного звука и графики. Поэтому не будем забывать об удовольствии!^ ВЫСОКОСКОРОСТНЫЕ ТРЕХМЕРНЫЕ СПРАЙТЫНа самом деле, новых понятий в этой главе не появится. Скорее, речь пойдет о практическом применении тех технологий и концепций, которые мы обсудили в предыдущих главах. Обычно я никогда не рассматриваю практическую реализацию в книгах подобного плана. Это связано с тем, -что создание программы - скорее, творческий, чем технологический процесс. Однако в данном случае я изменил свое решение, так как хочу, чтобы вы четко разобрались в ряде основополагающих концепций.За последние несколько лет мир компьютерных игр пережил несколько сенсаций (и появление игры DOOM одна, но не единственная, из них). К этим сенсациям, в том числе следует, отнести и появление на свет игры Wing Commander, написанной Крисом Робертсом (Chris Roberts). Увидев ее впер вые, я был так потрясен, что вскоре она стала моей любимой игрой. В Wing Commander и других играх подобного плана была использована та же технология визуализации спрай тов, что и в играх типа DOOM,Образы в Wing Commander - это или простые макеты, или создаваемые компьютером объекты, преобразованные в цифровую форму двухмерного спрайта.. При движении по экрану эти спрайты видоизменяются по определенным математическим законам, создавая полное ощущение перспективы. Однако, хотя с формальной точки зрения данные изображения и не являются трехмерными, над ними производятся стандартные процедуры удаления невидимых поверхностей и другие математические расчеты для трехмерных изображений. Другими словами, это проекции трехмерных объектов на плоские многоугольники, которые собственно, и являются спрайтами.Для изготовления игры типа Wing Commander не требуется сверхсложной математики. Однако подобная игра содержит массу тонкостей, хитрых приемов и замечательных алгоритмов. Посмотрим, сможем ли мы разобраться в некоторых из них, обсудив следующие вопросы:Механика трехмерных спрайтов;Аксонометрические преобразования;Правильный расчет масштаба;Видимый объем;Новая версия масштабирования;Отсечение в трехмерном пространстве спрайтов;Построение траекторий;Удачный угол зрения на спрайты; Трехмерное звездное небо; Оцифровка объектов и моделирование; Создание съемочной студии; Цветовая палитра.  Механика трехмерных спрайтов Трехмерные спрайты очень похожи на двухмерные. По правде говоря, они и являются плоскими, просто нам кажется, что они объемные. Такое восприятие обуславливается тем, как они движутся по экрану и как при этом изменяется их размер- Двухмерные спрайты могут перемещаться только по осям Х и У, трехмерные же должны перемещаться ло всем трем осям — X, У и Z. Движение вдоль оси Z, фактически, осуществляется только в математическом плане за счет изменения координат спрайта одновременно по осям Х и Y, а также вычислением его размера, определяемого координатой Z. Именно это и делает плоские картинки похожими на трехмерные. Конечно, мы опустили некоторые детали. Как может плоское изображение выглядеть трехмерным? Чтобы ответить на этот вопрос, нарисуем объект так; как бы он выглядел под определенным углом зрения в пространстве. В качествепримера к этой главе, я заснял на видеокамеру вращение игрушечного космического корабля, а затем оцифровал полученные кадры. Для этого я закрепил камеру и объект на определенном расстоянии друг от друга, как показано на рисунке 8.1, и для каждого снимка чуть-чуть поворачивал игрушку вокруг вертикальной оси. Таким образом, я получил 12 кадров, которые изображали корабль под разными углами. Эти кадры приведены на рисунке 8.2. Если мы последовательно отобразим их на экране, то получим иллюзию вращающегося в сотне шагов от нас космического корабля.Трехмерный вид спрайтов обуславливается двумя различными факторами:Во-первых, мы сканируем (или рисуем) объект в различных ракурсах. В конечном счете, лучше всего получить изображение во всех возможных позициях вращения, но это не получится из-за того объема памяти, необходимой для хранения всех изображений. Например, для этой главы я создал спрайты размером 80х48 пикселей. Это значит, что каждое изображение требует 3840 байт. На первый взгляд эта величина не кажется слишком большой, но только до тех пор, пока вы не подсчитаете объем памяти, занимаемый всеми кадрами, выполненными под разными углами зрения. Если мы хотим просто вращать объект относительно оси Y с шагом в 30 градусов и рассматривать его с 4 разных уровней высоты, на это уйдет 12х4х3840=184К. А теперь представим, что нам понадобились изображения большего размера либо несколько подобных изображений (или и то и другое сразу)! Для экономии памяти можно оцифровывать только некоторые из требуемых изображений, а недостающие получать преобразованием имеющихся по мере необходимости. Например, можно нарисовать виды объекта только под углами зрения в пределах от 0 до 180 градусов, а для оставшихся 180 градусов получать изображение из исходного набора данных уже программным путем;Второй фактор, с помощью которого достигается иллюзия трехмерности это учет перспективы при перемещении спрайта. С помощью этого достигается эффект передвижения объектов вперед и назад относительно точки проекции и горизонта.Мы можем считать, что спрайты - это точки в трехмерном пространстве и работать с ними на основе этого предположения. Тогда мы можем рассчитывать коэффициенты их масштабирования и строить изображение в соответствии с расстоянием до них от наблюдателя (то есть от вас), Наконец, во время перемещения спрайтов по экрану мы должны выбирать кадры, соответствующие углу наблюдения, под которым они рассматриваются.А теперь поговорим о том, как поддерживать иллюзию объемности. Если игрок, путешествуя по игровому пространству, заходит за трехмерный объект, он должен увидеть его сзади, а отнюдь не с боку, как это было бы при перемещении слева направо. Учет этого обстоятельства основывается на отслеживании траектории объекта и вектора взгляда игрока. Мы обсудим это подробно немножко позже в настоящей главе, а сейчас я просто хотел упомянуть обо всем, что необходимо для достижения впечатления трехмерности при работе со спрайтами. Аксонометрические преобразованияМы уже говорили об этом раньше (в шестой главе, «Третье измерением). Для воспроизведения объектов на экране компьютера используются аксонометричес кая проекция и связанные с ней математические преобразования, так как эта проекция выглядит более реалистично, чем параллельная (ортогональная). При построении аксонометрической проекции значения координат Х и Y модифицируются с учетом координаты Z (то есть расстояния от наблюдателя до плоскости просмотра, которой в нашем случае является экран), создавая тем самым иллюзию реальной перспективы.Для правильного аксонометрического преобразования трехмерного спрайта мы должны использовать его центр в качестве его позиции или локального центра координат. Это весьма важно! Если мы будем за центр координат принимать верхний левый угол спрайта (как мы это делали раньше), то получим искаженную картину. Всегда в качестве локального центра координат используйте середину объекта. Необходимость этого вызвана тем, что образ должен масштабироваться равномерно от его центра, а не от верхнего левого угла. (Запомнили? Повторите. Отлично!)^ Формула 8.1. Аксонометрическая проекция спрайта.Математический аппарат аксонометрии прост: нам требуется знать только значение координаты Z и расстояние до объекта. Имея эти данные, мы получаем новое положение проекции спрайта следующим образом: х_Projected = view_distance * х_sprite / z_sprite у_Projected = view_distance * у_sprite / z_spriteТакой метод проекции работает четко: спрайты перемещаются вдоль линий перспективы в окне просмотра. Однако есть одна тонкость, которую необходимо обсудить. Речь идет о том, что я назвал бы пространственным искажением. Оно возникает, когда вы смешиваете одну систему виртуальных объектов с другой. Представим, например, что вы помещаете трехмерный спрайт в пространство, созданное трассировкой лучей. По отношению к этому пространству спрайт будет передвигаться и масштабироваться некорректно из-за того, что спрайт и стены создавались на основе двух различных способов построения перспективы. Решить эту проблему можно с помощью всего лишь одного-единственного умножения во время построения проекции. Мы должны умножить координаты спрайта на коэффициент масштаба внутренней размерности. Этот поправочный коэффициент отображает одно математическое пространство на другое. По существу, мы должны масштабировать пространство спрайтов таким образом, чтобы оно соответствовало пространству трассированных лучей (или любому другому пространству, в которое мы собираемся его поместить). Конеч но, существует строгий математический способ расчета этого коэффициента (если вы любите точность, напишите мне письмо, и я покажу вам, как это делается). Что же касается меня лично, то я просто играю с расстояниями до спрайтов, пока объекты не начнут выглядеть вполне приемлемо. Итак, мы в общих чертах разобрались с проецированием спрайта на экран. На всякий случай повторю еще раз: В качестве начала координат мы используем центр спрайта;  Затем мы делим координаты спрайта Х и Y на координату 2;  После этого умножаем полученный результат на поправочный коэффициент, учитывающий расстояние до объекта и фактор внутреннего масштаба пространства.Чем-то напоминает рецепт колдовского зелья, не так ли? Тем не менее, выполнив эти операции и подвигав спрайт по экрану, мы получим иллюзию если не трехмерного, то, по крайней мере, двух с половиной-мерного изображения. Таким образом, правильно поместив на экран объект, мы должны еще научиться корректно масштабировать его размеры при отдалении (или приближении) спрайта от наблюдателя. Правильный расчет масштабаМы не учли одну вещь: масштаб спрайта. Нам надо увеличивать или уменьшать размеры спрайта, исходя из его положения на оси Z по отношению к наблюдателю.Другими словами, мы должны отыскать формулу, которая бы позволяла нам получать подходящий размер или масштаб в пикселях для прорисовки спрайта. К счастью, масштаб обратно пропорционален значению Z-координаты спрайта (то есть расстоянию от спрайта до игрока). Следовательно, для вычисления точного масштаба (или, по крайней мере, хорошо смотрящегося масштаба), мы можем использовать Z-координату спрайта с некоторым поправочным коэффициентом.Опять-таки не надо забывать о пространственных искажениях, возникающих при смешивании одной системы виртуальных объектов с другой. Поправочный коэффициент, сглаживающий эти искажения, легче всего подобрать экспериментально. Наша масштабирующая подсистема будет вычислять пиксельный размер, в соответствии с которым растровые текстуры должны будут соответственно сжиматься и растягиваться. Сам расчет масштаба на основании Z-координаты спрайта будет производиться по формуле 8.2.Формула 8.2. Расчет масштабирования. scale=scale_distance/sprite_z, где scale_distance расстояние - визуально дающее хороший результат.Мы знаем, что создание трехмерной графики не может быть легким делом с ней надо повоевать! И мне это даже нравится! Существует еще одна небольшая проблема - отсечение. И большая часть этой главы посвящена именно этой проблеме. Видимый объемКак мы узнали в главах, посвященных трехмерной графике, базирующейся на многоугольниках (глава шестая, «Третье измерение» и седьмая, «Улучшенная битовая графика и специальные эффекты»), объекты должны быть отсечены в пределах видимого объема (или усеченной пирамиды просмотра). Это достигается путем определения ребер каждого многоугольника и отсечения их шестью гранями видимого объема. Возникающая при этом проблема состоит в том, что объем просмотра представляет собой трехмерный трапецоид, состоящий из шести интересующих нас плоскостей, так как это показано на рисунке 8.3.Мы, конечно, не хотим рассчитывать пересечения спрайтов с произвольными плоскостями. Это было бы уж слишком! Но если мы вначале спроецируем каждый спрайт в аксонометрии и рассчитаем их масштаб, то сможем превратить объем просмотра в прямоугольник. Теперь, так как мы выполняем обратную операцию, мы сможем отсечь спрайты куда как более легким образом, чем при использовании уравнений произвольных плоскостей.Этот прием основывается на том факте, что объем просмотра уже является аксонометрической проекцией. Если мы отсечем края трехмерного объекта? видимым объемом прежде, чем спроецируем этот объект, мы будем обязаны использовать трапецеидальные формы объема просмотра. Однако, если мы вначале спроецируем объект с учетом перспективы, а затем отсечем его прямоугольными границами видимого объема, то.результат, полученный таким образом, будет полностью совпадать с результатом, достигаемым первым способом. Отсечение же в плоскостях, параллельных плоскости просмотра, сводится к простому условному оператору, в котором проверяется, является ли спрайт слишком далеким или слишком близким по отношению к вам.В случае видеорежима l3h мы можем отсекать все спрайты по размерам экрана или четырехугольника, границы которого определяют точки (0,0) и (319,199). Отсечение в плоскостях, параллельных плоскости просмотра, осуществляется с помощью простого теста на выполнение условия: если спрайт находится внутри наблюдаемого Z-пространства, то визуализируйте объект, а в противном случае игнорируйте его. Отсечение в этих плоскостях выглядит так просто оттого, что в действительности спрайты — это прямоугольные многогранники, расположенные перпендикулярно линии взгляда, или параллельно плоскости просмотра (вы можете думать, как вам больше нравится, но на самом деле это одно и то же).Я полагаю, что, поэкспериментировав с отсечением дальней плоскостью, вы сделаете так, чтобы объект размером меньше, чем в один пиксель по любому измерению (после масштабирования) вообще не рисовался. Выбирая ближнюю плоскость отсечения, старайтесь сделать так, чтобы приближающийся объект не выглядел как под микроскопом с многократно увеличенными пикселями. Новая версия масштабированияПрежде чем попытаться реализовать алгоритм отсечения, мы должны разобраться с основами операций масштабирования. Поскольку масштабирование и отсечение идут рука об руку, мы должны сначала написать программу изменения масштаба, а затем адаптировать ее для процесса отсечения.Механизм масштабирования мы показали в седьмой главе, «Улучшенная битовая графика и спецэффекты» (Листинг 7.9). Для масштабирования текстуры стен в этом алгоритме был использован не совсем обычный подход. Каждая стена рассматривалась не как обычная двухмерная матрица, имеющая высоту и ширину, а разбивалась на отдельные одномерные столбцы. В результате программе нужно было масштабировать только столбцы шириной в один пиксель. (Кстати, простой текстурированный пиксель называется текстелем (textel).)Для реализации двухмерного масштабирования мы слегка модифицируем код, представленный в Листинге 7.9. В новом варианте будут использованы только целые числа, а индексы масштабирования будут предварительно подсчитаны и занесены в таблицу соответствий. Текст новой программы масштабирования приведен в Листинге 8.1.

1   ...   13   14   15   16   17   18   19   20   ...   37 