

	 Блокировки
	 

 






Уровни изоляции транзакций
					
					
					
					Стандарт ANSI/ISO для SQL устанавливает различные уровни изоляции для операций, выполняемых над БД, которые работают в многопользовательском режиме. Уровень изоляции определяет, может ли читающая транзакция считывать ("видеть") результаты работы других одновременно выполняемых завершённых и/или незавершённых пишущих транзакций (табл. 5.1). Использование уровней изоляции обеспечивает предсказуемость работы приложений.
 Таблица 5.1. Уровни изоляции по стандарту ANSI / ISO
  Уровень изоляции
   Черновое чтение
   Неповторяемое чтение
   Фантомы
   Read Uncommited – чтение незавершённых транзакций
   да
   да
   да
   Read Commited – чтение завершённых транзакций
   нет
   да
   да
   Repeatable Read – повторяемое чтение
   нет
   нет
   да
   Serializable – последовательное чтение
   нет
   нет
   нет
  По умолчанию в СУБД обычно установлен уровень Read Commited.
 Уровень изоляции позволяет транзакциям в большей или меньшей степени влиять друг на друга: при повышении уровня изоляции повышается согласованность данных, но снижается степень параллельности работы и, следовательно, производительность системы. Блокировка – это временное ограничение доступа к данным, участвующим в транзакции, со стороны других транзакций..
   
 Блокировка относится к пессимистическим алгоритмам, т.к. предполагается, что существует высокая вероятность одновременного обращения нескольких пишущих транзакций к одним и тем же данным. Различают следующие типы блокировок:
 по степени доступности данных: разделяемые и исключающие; по множеству блокируемых данных: строчные, страничные, табличные; по способу установки: автоматические и явные. Строчные, страничные и табличные блокировки накладываются соответственно на строку таблицы, страницу (блок) памяти и на всю таблицу целиком. Табличная блокировка приводит к неоправданным задержкам исполнения запросов и сводит на нет параллельность работы. Другие виды блокировки увеличивают параллелизм работы, но требуют накладных расходов на поддержание блокировок: наложение и снятие блокировок требует времени, а для хранения информации о наложенной блокировке нужна дополнительная память (для каждой записи или блока данных).

 Разделяемая блокировка, установленная на определённый ресурс, предоставляет транзакциям право коллективного доступа к этому ресурсу. Обычно этот вид блокировок используется для того, чтобы запретить другим транзакциям производить необратимые изменения. Например, если на таблицу целиком наложена разделяемая блокировка, то ни одна транзакция не сможет удалить эту таблицу или изменить её структуру до тех пор, пока эта блокировка не будет снята. (При выполнении запросов на чтение обычно накладывается разделяемая блокировка на таблицу.)
 Исключающая блокировка предоставляет право на монопольный доступ к ресурсу. Исключающая (монопольная) блокировка таблицы накладывается, например, в случае выполнения операции ALTER TABLE, т.е. изменения структуры таблицы. На отдельные записи (блоки) монопольная блокировка накладывается тогда, когда эти записи (блоки) подвергаются модификации.
 Блокировка может быть автоматической и явной. Если запускается новая транзакция, СУБД сначала проверяет, не заблокирована ли другой транзакцией строка, требуемая этой транзакции: если нет, то строка автоматически блокируется и выполняется операция над данными; если строка заблокирована, транзакция ожидает снятия блокировки. Явная блокировка, накладываемая командой LOCK TABLE языка SQL, обычно используется тогда, когда транзакция затрагивает существенную часть отношения. Это позволяет не тратить время на построчную блокировку таблицы. Кроме того, при большом количестве построчных блокировок транзакция может не завершиться (из-за возникновения взаимных блокировок, например), и тогда все сделанные изменения придётся откатить, что снизит производительность системы.
 Явную блокировку также можно наложить с помощью ключевых слов for update, например:
 for update, например:SELECT *FROM WHERE for update; При этом блокировка будет накладываться на те записи, которые удовлетворяют <условию>.
 И явные, и неявные блокировки снимаются при завершении транзакции.
 Блокировки могут стать причиной бесконечного ожидания и тупиковых ситуаций. Бесконечное ожидание возможно в том случае, если не соблюдается очерёдность обслуживания транзакций и транзакция, поступившая раньше других, всё время отодвигается в конец очереди. Решение этой проблемы основывается на выполнении правила FIFO (first input – first output): "первый пришел – первый ушел".
 Тупиковые ситуации (deadlocks) возникают при взаимных блоки-ровках транзакций, которые выполняются на пересекающихся множествах данных (рис. 5.3). Здесь приведён пример взаимной блокировки трех транзакций Ti на отношениях Rj. Транзакция T1 заблокировала данные B1 в от-ношении R1 и ждёт освобождения данных B2 в отношении R2, которые заблокированы транзакцией T2, ожидающей освобождения данных B3 в отношении R3, заблокированных транзакцией T3, которая не может продолжить выполнение из-за транзакции T1. Если не предпринимать никаких дополнительных действий, то эти транзакции никогда не завершатся, т.к. они вечно будут ждать друг друга.загрузка...

 Рис.5.3. Взаимная блокировка трех транзакций
 Существует много стратегий разрешения проблемы взаимной блокировки, в частности:



Взаимовлияние транзакций  | следующая ==> Защита баз данных
Дата добавления: 2014-02-24; просмотров: 435; Опубликованный материал нарушает авторские права?.

Не нашли то, что искали? Воспользуйтесь поиском google:
Не хотите "париться"? закажите платную работу!
	Лучшие изречения: На стипендию можно купить что-нибудь, но не больше...  1543 -  | 1421 -  или читать все...
   Read Uncommited – чтение незавершённых транзакций
   да
   да
   да
  