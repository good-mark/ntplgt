
Размещено на http://www.allbest.ru/

Размещено на http://www.allbest.ru/

Министерство Образования и Науки РК

Евразийский Национальный Университет им.Л.Н.Гумилёва

Факультет информационных технологий

Кафедра информационных систем

КУРСОВАЯ РАБОТА

На тему:

База данных: подсистема «ЗАГС»

Исполнитель: студентка 1 курса

Бегалыкызы А.

Научный руководитель:

Туребаева Р.Д.

Астана

2012

Содержание



Введение 

1. Разработка базы данных 

1.1 Постановка задачи

1.2 Разработка концептуальной модели базы данных и диаграммы классов

2. Проектирование программы

2.1 Общий принцип работы программы

2.2 Разработка интерфейса пользователя

2.3 Разработка запросов к базе данных

2.4 Создание отчётов

Заключение

Список использованной литературы

Приложение 

Введение



C++ -- компилируемый статически типизированный язык программирования общего назначения. Поддерживает такие парадигмы программирования как процедурное программирование, модульность, раздельная компиляция, обработка исключений, абстракция данных, типы (объекты), виртуальные функции, объектно-ориентированное программирование, обобщенное программирование, контейнеры и алгоритмы, сочетает свойства как высокоуровневых, так и низкоуровневых языков. В сравнении с его предшественником -- языком C, -- наибольшее внимание уделено поддержке объектно-ориентированного и обобщённого программирования. Название «C++» происходит от названия языка C, в котором унарный оператор ++ обозначает инкремент переменной. Являясь одним из самых популярных языков программирования, C++ широко используется для разработки программного обеспечения. Область его применения включает создание операционных систем, разнообразных прикладных программ, драйверов устройств, приложений для встраиваемых систем, высокопроизводительных серверов, а также развлекательных приложений (например, видеоигры). Существует несколько реализаций языка C++ -- как бесплатных, так и коммерческих. Наиболее популярны проект GNU, Microsoft, Intel и Embarcadero (Borland). C++ оказал огромное влияние на другие языки программирования, в первую очередь на Java и C#. При создании C++ Бьёрн Страуструп стремился сохранить совместимость с языком C. Множество программ, которые могут одинаково успешно транслироваться как компиляторами C, так и компиляторами C++, довольно велико -- отчасти благодаря тому, что синтаксис C++ был основан на синтаксисе C.

База данных -- это набор, совокупность файлов, в которых находится информация. Программная система (приложение), обеспечивающая работу с базой данных (файлами данных) называется системой управления базой данных (СУБД). Следует обратить внимание, что вместо термина СУБД часто используется термин база данных, при этом файлы данных и СУБД рассматриваются как единое целое.

Информацию компьютерных баз данных обычно выводят на экран в виде таблиц. Поэтому часто вместо словосочетания "файл данных" используют словосочетание "таблица данных" или просто "таблица".

Целью работы является разработка программы на С++ для обработки данных, представленных в виде таблиц базы данных. Программа должна корректно обрабатывать данные, представленные в виде таблиц с информацией о дисциплинах, преподавателях и студентах. 

Программа будет использоваться для хранения данных и создания отчетов в области образования. Программа должна позволять по внесенным исходным данным производить подсчёты, используя вычисляемые поля. В программе должен быть реализован поиск по основным полям. Кроме дополнительных отчетов, программа должна содержать основной отчет по дисциплинам, содержащий полную информацию и результаты вычислений из вычисляемых полей.

Исходя из задания, создаваемая программа должна работать с таблицами баз данных (например, Paradox), давая возможность пользователю как вводить данные, так и получать информацию из введенных ранее данных.

Программа должна быть создана так, чтобы любой пользователь без труда мог разобраться во всех её функциях и возможностях. Следовательно, можно определить основные функции программы: 

1. запоминать вводимые значения, показывать базу данных;

2. добавлять, редактировать данные;

3. осуществлять поиск в базе;

4. выдавать информацию по различным запросом;

5. удалять и сохранять изменения в базе;

6. сохранять всю информацию, а также иметь доступ к открытию информации;

1. Разработка концептуальной модели базы данных и диаграммы классов



Концептуальная модель базы данных - это высокоуровневая объектно-ориентированная модель предметной области, представляющая объектную область в виде набора объектов, обладающих определенными свойствами и находящимися в некоторых отношениях. Основная цель разработки высокоуровневой модели данных заключается в создании модели пользовательского восприятия данных и согласовании большого количества технических аспектов, связанных с проектированием базы данных. Концептуальная модель данных не привязана к конкретной физической реализации баз данных и не зависит от конкретной СУБД. Концептуальная модель создается на основе представлений о предметной области каждого типа пользователей, представляющих собой набор данных, необходимых пользователю для решения своих задач. Основные концепции модели включают такие понятия как сущность (объект), отношение (связь), типы сущностей, типы связей и атрибуты.

Из описания предметной области извлечем все типы сущностей (пример):

Муж;

Жена;

ЗАГС;

Эти сущности взаимодействуют по следующей схеме (схема1):

Схема №1 (структурная связь доминирующих таблиц) 

Эти сущности должны быть представлены в виде таблиц. В программе должны содержаться три таблицы, две из которых соответствуют сущностям из описания предметной области, а одна является вспомогательной, данные из которой нужны для вычислений основной таблицы. Эта вспомогательная первая таблица содержит коэффициенты, используя которые программа производит расчёты полей.

Все поля данных таблиц соответствуют характеристикам этих таблиц. Они представлены в виде диаграммы классов.

Диаграмма классов - это набор статических, декларативных элементов модели. На такой диаграмме классы изображаются в виде прямоугольников, а статические (постоянные) отношения между ними - в форме дуг. Поддерживаются три основных типа отношений между классами:

- ассоциации.

- иерархии агрегирования и композиции.

- иерархия обобщения/специализации

Эта концепция хорошо показана на рисунке №1. 

Рисунок 1

2. Проектирование программы



Разработку программы я начала с создания главного меню с помощью компонентов MainMenu и ActionList. Сначала создаем шаблон меню с помощью компонента ActionList, в котором мы создаем пункты меню, указывая их имена, клавиши быстрого доступа к ним. Также в этом же компоненте можно указать картинки к данным кнопкам, связав компонент ActionList c компонентом ImageList, через его свойство Images. 

Затем с помощью компонента MainMenu создаем главное меню, выбирая пункты меню из свойства Action.Таким образом, получаем меню, структура которого представлена следующим образом (рисунок №2):

Рисунок №2. Структура главного меню

Далее создадим псевдоним (альянс), в котором будут храниться все наши таблицы. Псевдоним содержит всю информацию, необходимую для обеспечения доступа к базе данных. Эта информация сообщается только один раз при создании псевдонима. Существует несколько способов создания альянса. Воспользуемся встроенной в Borland Builder C++ программой BDE Administrator. Произведем команду Tools | bdeadmin.exe. Откроется окно программы, где необходимо нажать Object | New выбрать базу данных (в нашем случае Paradox), ввести имя, указать путь, т.е. папку, где будут хранится все таблицы этого альянса, и произвести команду Object | Apply как показано на рисунке№3.

Рисунок № 3. Окно программы BDE Administrator 

Следующим шагом будет создание таблиц с помощью Database Desktop. Эта программа встроена в Borland Builder C++. С её помощью создадим нужные нам таблицы как видно на рисунке №4.
 
Рисунок №4. Структура таблицы «ЗАГС»

Далее мы видим структуру следующей таблицы. (Рисунок№5)
 
Рисунок №5. Структура таблицы «Муж»

Структура следующей таблицы показана на рисунке №6.

Рисунок № 6. Структура таблицы «Жена»

Создав таблицы, необходимо загрузить их в нашу программу. Это можно сделать используя ряд компонентов, но для начала создадим DataModule, на котором они будут размещены. Это делается с помощью команды File | New | Data Module. Разместим на нем три компонента Table и DataSource, как показано на рисунке №8.

Рисунок 8. Размещение компонентов в Data Module

В компоненты Table загрузим созданные таблицы, используя свойства компонента Table - DatabaseName, в котором укажем имя альянса, и TableName, где запишем имя таблицы. Компоненты DataSource нужны для связи компонентов Тable с компонентом графического отображения таблиц на экране DBGreed, т.е. в свойстве DataSet компонента DataSource указываем соответствующий Table, а в свойстве DataSource компонента DBGreed указываем нужный DataSource.

В данной программе используется только один компонент DBGreed. При выборе в компоненте ListBox нужной таблицы, данная таблица и отображается в компоненте DBGreed. 

Редактирование таблицы производится с помощью стандартных кнопок «Добавить», «Изменить», «Записать», «Отменить», «Удалить», которые используют встроенные функции языка С++ insert(), edit(), post(), cancel(), delete(). Код использования этих функций и реализации кнопок приведен в приложении. Кнопки перемещения по таблице используют функции last(), first(), next(), prior(). 

Поиск в таблицах с фильтрацией производится с помощью свойств компонента Table - Filter и Filtered. Пример поиска в таблице «Дисциплины» по полю названия дисциплины: 

DM1->Table1->Filtered=true;

DM1->Table1->Filter= "Discipline_name='" + ComboBox1->Text + "'"; 

Поиск в таблицах без фильтрации производится с помощью функции locate(). Пример предыдущего поиска без фильтрации:

TLocateOptions SearchOptions;

if(!DM1->Table1->Locate("Discipline_name",ComboBox1->Text,

SearchOptions <<loPartialKey<< loCaseInsensitive)) ShowMessage("Запись не найдена.");

Эти способы поиска фильтрации использованы в кнопках «Найти» и «Завершить поиск» (коды которых имеются в приложении). Для удобного использования поиска для каждой таблицы имеются свои компоненты RadioGroup с названиями полей для поиска, как показано на рисунке №9. 

Рисунок №9 Область окна для поиска по таблице «ЗАГС»

В программе использовано много вычисляемых полей для основной таблицы «ЗАГС». Они созданы в компоненте Table, который соответствует данной таблице. Вычисляемые поля создаются следующим образом: двойным щелчком по компоненту Table откроем небольшое окно доступа к полям таблицы; в этом окне после щелчка правой кнопкой мыши откроется контекстное меню, в котором необходимо выбрать пункт New field; после чего откроется окно создания нового поля (Рисунок №10), в котором указываются нужные свойства вычисляемого поля; по нажатию кнопки «ok» поле будет создано.
 
Рисунок №10. Окно отображения полей таблицы (слева) и окно создания вычисляемого поля

После создания поля необходимо прописать код, по которому будут производиться вычисления в данном поле. Весь этот код пишется в событии CalcFields соответствующего компонента Table. Пример для вычисления поля, в котором отражается количество кредитов по известному количеству часов:

void __fastcall TDM1::Table1CalcFields(TDataSet *DataSet)

{Table1Lecture_cred->Value = Table1Lecture_hours->Value/15;}

2.1 Общий принцип работы программы



При запуске программы появляется окно, содержащее поле для выбора таблицы. После выбора таблицы происходит открытие этой таблицы и все её данные отражаются в специально-отведенной части. Таблица «ЗАГС» является основной и использует данные из других таблиц для подсчёта результата в своих вычисляемых полях. Кроме вычисляемых полей, в ней содержатся основные поля, такие как название Муж, Жена. Для этих полей производится расчет данных. 

Посчитав информацию о дате рождения с указанного поля, программа заносит возраст в соответствующие поля главной таблицы. Затем, исходя из этих данных и данных из таблицы «Муж» производится подсчет различных полей в Отчет, содержащих информацию о нагрузке преподавателей.

Таблица «Муж» содержит информацию о мужьях, в которой отражены их личные данные. 

Таким образом, после выбора таблицы пользователю предоставляется выбор действия. Пользователь может просто просматривать информацию, используя интерфейс программы.

Программа позволяет осуществлять поиск данных, используя соответствующую область окна, где пользователь указывает поля и информацию, по которой будет производиться поиск. Поиск можно производить, как использую фильтрацию данных, так и не используя её.

Эти режимы переключаются с помощью пункта выбора «Нет фильтрации». 

Редактирование осуществляется с помощью кнопок «Добавить», «Изменить», «Записать», «Отменить», «Удалить». При добавлении новой записи заполняются только основные поля, не учитывая вычисляемых, а остальные поля заполняются после заполнения специальной панели и щелчка по кнопке «Изменить».

Кнопки «Записать», «Отменить» осуществляют редактирование отдельной ячейки таблицы, а кнопка «Удалить» полностью удаляет запись из таблицы.

В программе так же есть запросы и отчеты, которые выдают информацию по определенным характеристикам. 

Блок-схема: (структурная схема программы)

2.2 Интерфейс пользователя



В части интерактивного общения с пользователем СУБД отвечает следующим требованиям:

- должен быть реализован графический многооконный режим отображения данных и ведения диалога;

- должен быть обеспечен удобный, простой windows-совместимый интерфейс, интуитивно понятный для пользователя, который знает свою предметную область и не является специалистом в области информационных технологий; интерфейс должен быть оптимизирован для выполнения типовых и часто используемых прикладных операций. Внешний вид форм должен быть спроектирован в соответствии с требованиями, разработанными фирмой Microsoft. 

- взаимодействие пользователя с системой должно осуществляться на русском языке;

- интерфейс пользователя подсистемы должен способствовать уменьшению вероятности совершения оператором случайных ошибочных действий (ввод недопустимых значений в поля; удаление записей из основных таблиц, при наличии связанных записей при отсутствии каскадного удаления), должен поддерживать дружественную систему меню, предоставляющую пользователю выбор альтернативных действий.

При запуске программы открывается главная форма, показанная на рисунке №12.
 
Рисунок 12. Главное окно программы

Главная форма содержит кнопки редактирования (рисунок №13): 
 
Рисунок 13. Кнопки редактирования

После выбора нужной таблицы вся содержащаяся в ней информация отражается в соответствующей области основной формы. Например, информация из таблицы Муж отразится следующим образом (рисунок №15):

Рисунок №15. Окно отображения информации таблицы

Информацию в таблицах можно просматривать, использую мышь или клавиатуру, либо с помощью специальных кнопок программы, как показано на рисунке №16.

Рисунок № 16. Кнопки перемещения по таблице

Добавление новой записи осуществляется при нажатии кнопки «Добавить», а информация для добавления заносится в специальную панель, соответствующую выбранной таблице:

Изменение данных в записи осуществляется с помощью кнопки «Изменить», при нажатии которой происходит ввод данных в таблицу из соответствующей панели. Например, панель для изменения данных таблицы «Муж» показана на рисунке №17:

Рисунок № 17. Панель изменения данных

Поиск в базе также осуществляется с помощью соответствующей панели, в которой выбирается поле, по которому будет производиться поиск и вводятся данные для поиска. Например, панель поиска таблицы «ЗАГС» видна на рисунке №18:

Рисунок № 18. Панель поиска

Поиск можно производить, как с фильтрацией, так и без неё, используя для переключения между режимами пункт выбора (рисунок №19):

Рисунок № 19. Кнопка поиска

Заканчивается по нажатию кнопки «Завершить поиск» (рисунок №20):

Рисунок 20. Кнопка завершения поиска

При использовании поиска следует обратить внимание, что при выборе пункта для поиска, у которого нет поля ввода данных, ввод этих данных осуществляется не на панели поиска, а на панели добавления новой записи в таблицу, т.к. это поле является основным для этой таблицы. 

Все основные функции программы расположены в главном меню.

Структурная схема главного меню моей программы указана на блок-схеме № 21.

Размещено на http://www.allbest.ru/

Размещено на http://www.allbest.ru/

Рисунок 21. Структура главного меню

Кнопки редактирования располагаются как на форме, так и в главном меню, а остальные пункты, кроме отчетов и запросов, можно также найти и на панели инструментов например (Рисунок №22)

.

Рис 22. Кнопки быстрого доступа

Первая кнопка панели инструментов соответствует верхней кнопке «Сохранить» пункта «Файл» главного меню. 

Вторая кнопка панели инструментов соответствует нижней кнопке «Выйти» пункта «Файл» главного меню. 

Рисунок № 25. Пункты меню

Программа также содержит справку, которая включает краткие сведения о программе рисунке №26:

Рисунок № 26. Окно справки

Информацию об авторе можно найти в пункте главного меню «Справка» или же на панели инструмент

Рис 27. Окно информации об авторе

2.3 Разработка запросов к базе данных

Запросы обеспечивают простой доступ к определенному подмножеству полей и записей. Запросы в базе данных формируются на основании информации представленной в описании предметной области. Запросы записываются в виде выражений SQL.

В данной программе имеются два сформированных запроса. Выбрать их можно в пункте главного меню как показано на рисунке №28.
 
Рисунок № 28. Пункты меню для выбора запроса

Запросы в программе реализованы с помощью языка SQL и компонента программы Borland C++ Query:

1) Первый запрос «Инф-ция о гражданском состоянии мужского пола» записан следующим образом (рисунок №29): 

"Select Muzh as Муж, Tip_svidetelstva as Тип_свидетельства, Data_vydachi as Дата FROM ZAGS.db WHERE Zhena='"+Edit2->Text+"'"



Рисунок № 29. Вид окна запроса «Запрос1»

2) Второй запрос «Инф-ция о гражданском состоянии женского пола» на языке SQL выглядит так (рисунок №30):

"Select Zhena as Жена, Tip_svidetelstva as Тип_свидетельства, Data_vydachi as Дата FROM ZAGS.db WHERE Muzh='"+Edit1->Text+

Рисунок № 30. Вид окна запроса «Инф-ция о гражданском состоянии женского пола»

2.4 Создание отчётов



В программе имеется возможность просмотра данных, используя отчёты, которые в программе формируются с помощью компонента QReport программы Borland C++. Отчеты позволяют получать информацию из таблиц по определенным критериям, подобно запросам, но в отчетах информация представлена не в виде таблицы компонента DBGrid компонента Borland C++, а в виде тестового документа, подобно документам Microsoft Word и т.д.

В данной программе имеется три сформированных отчета, из которых один основной и два дополнительных. Первый дополнительный отчет «Контингент студентов» выводит данные из одноименной таблицы. Он создан с помощью компонента QReport, и во время проектирования выглядит так рисунок №31:

Рисунок № 31. Вид отчета «Список лиц, обращавшихся в ЗАГС» во время проектирования

Во время выполнения программы открыть отчеты можно с помощью пункта главного меню «Отчёты» (рисунок №32):

Рисунок 32. Пункты для выбора отчета

Во время выполнения программы отчет выглядит следующим образом (рисунок №33):

Рисунок 33. Вид отчета «Список лиц, обращавшихся в ЗАГС по состоянию на ___(дата)» во время работы программы.

Рисунок №34 отформатированный отчёт. 

Второй отчет также содержит информацию из одной таблицы «ЗАГС». Информация в нем представлена, как набор данных об одном физическом лице, в отличии от предыдущего отчета, где данные были в виде таблицы. Создан этот отчёт с помощью компонента QReport:

Для работы с отчётами использование компоненты QReport требует дополнительных компонентов. 

И выходные данные показаны на рисунке № 35.
 
Рисунок №35. Вид отчета «Информация о гражданском состоянии данного лица» во время проектирования

В ходе выполнения программы этот отчёт представлен в следующем виде (рисунок №36):

Рисунок № 36. Вид отчета «Информация о гражданском состоянии данного лица» во время работы программы

Главным преимуществом отчетов является то, что их можно распечатать с помощью принтера. Основной отчет представляет собой информацию, взятую из таблицы «ЗАГС». Все данные из вычисляемых полей также входят в этот отчет. Как и два предыдущих отчёта, он создан с помощью QReport.

Заключение 

Для успешной реализации проекта необходимо разбить собранную информацию на отдельные модули. Чем качественней вы проработаете и нормализуете структуру свой базы данных, тем надежнее и производительней будет ее работа. Конечно, по сравнению с профессиональными базами данных, данный проект содержит небольшое количество таблиц. Но именно на примере этого проекта мы можем научиться нормализовывать структуру данных. Построив схему данных, мы можем наглядно показать связь между таблицами и схему передачи данных. 

Таблицы выполняют основные функции работы базы данных. Функции накопителей данных и упорядочения, необходимо правильное составление и нормализация схемы данных, данные таблицы и схема данных приведены к третьей нормальной форме. В данной схеме детально показана связь и соотношение данных. При дальнейшем использовании программного продукта будут выделены лишние и недостающие элементы, поскольку заранее все предусмотреть нельзя и структура проекта будет неоднократно изменяться. В простейших случаях современные средства проектирования позволяют создать небольшие системы, основываясь только на общих принципах построения реляционных баз данных.

В ходе выполнения курсовой работы была разработана программа на языке С++ для обработки данных из таблиц базы данных. Обработка данных включает: 

1) просмотр существующих данных;

2) редактирование данных;

3) дополнение информации;

4) удаление записей из таблиц;

5) поиск данных в таблицах по определенному критерию;

6) просмотр данных из таблицы в виде запросов и отчетов;

Также в программе разработан графический интерфейс. 

При разработке программы использовались функции, массивы, циклы. Для разработки графической заставки использовал 

Конечно, для создания более значимого проекта нужно глубже изучить предметную область. Но для создания небольшого учебного проекта достаточно имеющихся у нас поверхностных знаний.

Список использованной литературы



1. Архангельский А.Я. Программирование в C++ Builder. М.: Бином, 2003.

2. Дейтел X., Дейтел П. Как программировать на Си. -М: Бином, 2000.

3. Паннас К., Мюррей У. Программирование на Си и Си++. -К.:Ирина, BHV, 2000.

4. Дьюхарст С., Старк К. Программирование на Си++. - Киев, 1993.

база данный программа интерфейс

Приложение



//---------------------------------------------------------------------------

#include <vcl.h>

#pragma hdrstop

#include "Unit1.h"

#include "Unit2.h"

#include "Unit3.h"

#include "Unit4.h"

#include "Unit6.h"

#include "Unit5.h"

#include "Unit7.h"

#include "Unit8.h"

#include <DateUtils.hpp>

#include "MainMenu.h"

bool CanPost;

//---------------------------------------------------------------------------

#pragma package(smart_init)

#pragma resource "*.dfm"

TZAGS *ZAGS;

//---------------------------------------------------------------------------

__fastcall TZAGS::TZAGS(TComponent* Owner)

: TForm(Owner)

{

}

//---------------------------------------------------------------------------

void __fastcall TZAGS::AExitExecute(TObject *Sender)

{

if ((DataModule1->Table1->Modified==True) && CanPost)

{DataModule1->Table1->Active=false;

DataModule1->Table1->Post(); }

if ((DataModule1->Table2->Modified==True) && CanPost)

{DataModule1->Table2->Active=false;

DataModule1->Table2->Post();}

if ((DataModule1->Table3->Modified==True) && CanPost)

{DataModule1->Table3->Active=false;

DataModule1->Table3->Post(); }

Close();

}

//---------------------------------------------------------------------------

void __fastcall TZAGS::AautorExecute(TObject *Sender)

{

Form3->Show();

}

//--------------------------------------------------------------------------

void __fastcall TZAGS::N3Click(TObject *Sender)

{

CanPost=true;

if (DataModule1->Table1->Modified==True )

DataModule1->Table1->Post();

if (DataModule1->Table2->Modified==True )

DataModule1->Table2->Post();

if (DataModule1->Table3->Modified==True )

DataModule1->Table3->Post();

CanPost=false;

}

//---------------------------------------------------------------------------

void __fastcall TZAGS::N2Click(TObject *Sender)

{

DataModule1->Table1->Open();

DataModule1->Table2->Open();

DataModule1->Table3->Open();

DataModule1->Table1->Active=true ;

DataModule1->Table2->Active=true;

DataModule1->Table3->Active=true ;

}

//---------------------------------------------------------------------------

void __fastcall TZAGS::BitBtn3Click(TObject *Sender)

{

if ((DataModule1->Table1->Modified==True) && CanPost)

{DataModule1->Table1->Active=false;

DataModule1->Table1->Close(); }

DataModule1->Table1->Close();}

//---------------------------------------------------------------------------

void __fastcall TZAGS::BitBtn2Click(TObject *Sender)

{ if (Application->MessageBox("Действительно хотите удалить запись?",

"Подтвердите удаление записи",MB_YESNO+MB_ICONEXCLAMATION)==IDYES)

{ if (PageControl1->ActivePage== TabSheet1);

DataModule1->Table1->Delete();

if (PageControl1->ActivePage== TabSheet2);

DataModule1->Table2->Delete();

if (PageControl1->ActivePage== TabSheet3);

DataModule1->Table3->Delete(); }

}

//---------------------------------------------------------------------------

void __fastcall TZAGS::Button1Click(TObject *Sender)

{if (PageControl1->ActivePage==TabSheet1)

DataModule1->Table1->First();

else if (PageControl1->ActivePage==TabSheet2)

DataModule1->Table2->First();

else DataModule1->Table3->First();

}

//---------------------------------------------------------------------------

void __fastcall TZAGS::Button3Click(TObject *Sender)

{if (PageControl1->ActivePage== TabSheet1)

DataModule1->Table1->Prior();

else if (PageControl1->ActivePage== TabSheet2)

DataModule1->Table2->Prior();

else DataModule1->Table3->Prior();

}

//---------------------------------------------------------------------------

void __fastcall TZAGS::BitBtn5Click(TObject *Sender)

{ 

if (PageControl1->ActivePage== TabSheet1)

DataModule1->Table1->Edit();

if (PageControl1->ActivePage== TabSheet2)

DataModule1->Table2->Edit();

if (PageControl1->ActivePage== TabSheet3)

DataModule1->Table3->Edit();

}

//---------------------------------------------------------------------------

void __fastcall TZAGS::BitBtn4Click(TObject *Sender)

{if (DataModule1->Table1->Modified==True )

DataModule1->Table1->Cancel();

if (DataModule1->Table2->Modified==True )

DataModule1->Table2->Cancel();

if (DataModule1->Table3->Modified==True )

DataModule1->Table3->Cancel();

}

//---------------------------------------------------------------------------

void __fastcall TZAGS::Button2Click(TObject *Sender)

{

if (PageControl1->ActivePage== TabSheet1)

DataModule1->Table1->Last();

else if (PageControl1->ActivePage== TabSheet2)

DataModule1->Table2->Last();

else DataModule1->Table3->Last();

}

//---------------------------------------------------------------------------

void __fastcall TZAGS::Button4Click(TObject *Sender)

{

if (PageControl1->ActivePage== TabSheet1)

DataModule1->Table1->Next();

else if (PageControl1->ActivePage== TabSheet2)

DataModule1->Table2->Next();

else DataModule1->Table3->Next();

}

//---------------------------------------------------------------------------

void __fastcall TZAGS::PageControl1Change(TObject *Sender)

{

if (PageControl1->ActivePage== TabSheet1)

{ RadioButton4->Visible=false;

Edit2->Visible=true;

RadioButton2->Visible=true;}

else {RadioButton2->Visible=false;

RadioButton4->Visible=true;

Edit2->Visible=true;}

}

//---------------------------------------------------------------------------

void __fastcall TZAGS::FormActivate(TObject *Sender)

{

PageControl1->ActivePage=TabSheet1;

}

//---------------------------------------------------------------------------

void __fastcall TZAGS::FormCreate(TObject *Sender)

{

RadioButton2->Visible=true;

RadioButton4->Visible=false;

Edit2->Visible=true;

}

//---------------------------------------------------------------------------

void __fastcall TZAGS::Button7Click(TObject *Sender)

{ 

if (RadioButton3->Checked==true)

{if (PageControl1->ActivePage== TabSheet1)

{DataModule1->Table1->Filtered=true;

DataModule1->Table1->Filter="Data_vydachi='" + Edit1->Text +"'"; }

if (PageControl1->ActivePage== TabSheet2)

{DataModule1->Table2->Filtered=true;

DataModule1->Table2->Filter="Data_rozhdeniya='" + Edit1->Text +"'"; }

if (PageControl1->ActivePage== TabSheet3)

{DataModule1->Table3->Filtered=true;

DataModule1->Table3->Filter="Data_rozhdeniya='" + Edit1->Text +"'"; } }



if (RadioButton4->Checked==true)

{if (PageControl1->ActivePage== TabSheet2)

{DataModule1->Table2->Filtered=true;

DataModule1->Table2->Filter="FIO_muzha='"+Edit2->Text+"'"; }

else if (PageControl1->ActivePage== TabSheet3)

{DataModule1->Table3->Filtered=true;

DataModule1->Table3->Filter="FIO_zheny='"+Edit2->Text+"'"; } }

if (RadioButton2->Checked==true)

if (PageControl1->ActivePage== TabSheet1)

{DataModule1->Table1->Filtered=true;

DataModule1->Table1->Filter="Tip_svidetelstva='" + Edit2->Text +"'";}

}

//---------------------------------------------------------------------------

void __fastcall TZAGS::N5Click(TObject *Sender)

{ if (PageControl1->ActivePage== TabSheet1)

DataModule1->Table1->Insert();

if (PageControl1->ActivePage== TabSheet2)

DataModule1->Table2->Insert();

if (PageControl1->ActivePage== TabSheet3)

DataModule1->Table3->Insert();

CanPost=true; }

//---------------------------------------------------------------------------

void __fastcall TZAGS::Aprogram1Click(TObject *Sender)

{

Form8->Show();

}

//---------------------------------------------------------------------------

void __fastcall TZAGS::N12Click(TObject *Sender)

{

InfForOtchet1->Show();

}

//---------------------------------------------------------------------------

void __fastcall TZAGS::N21Click(TObject *Sender)

{

InfForOtchet2->Show();

}

//---------------------------------------------------------------------------

void __fastcall TZAGS::BitBtn1Click(TObject *Sender)

{ if (PageControl1->ActivePage== TabSheet1)

DataModule1->Table1->Insert();

if (PageControl1->ActivePage== TabSheet2)

DataModule1->Table2->Insert();

if (PageControl1->ActivePage== TabSheet3)

DataModule1->Table3->Insert();

CanPost=true; }

//---------------------------------------------------------------------------

void __fastcall TZAGS::Button5Click(TObject *Sender)

{

if (RadioButton2->Checked==True)

DataModule1->Table1->Filtered=true;

DataModule1->Table1->Filter= "FIO_muzha='" + Edit1->Text+"'";

}

//---------------------------------------------------------------------------

void __fastcall TZAGS::N7Click(TObject *Sender)

{

if (Application->MessageBox("Действительно хотите удалить запись?",

"Подтвердите удаление записи",MB_YESNO+MB_ICONEXCLAMATION)==IDYES)

{ if (PageControl1->ActivePage== TabSheet1);

DataModule1->Table1->Delete();

if (PageControl1->ActivePage== TabSheet2);

DataModule1->Table2->Delete();

if (PageControl1->ActivePage== TabSheet3);

DataModule1->Table3->Delete(); }

}

//---------------------------------------------------------------------------

void __fastcall TZAGS::RadioButton1Click(TObject *Sender)

{

if (RadioButton1->Checked==true)

{if (PageControl1->ActivePage== TabSheet1)

DataModule1->Table1->Filtered=false;



if (PageControl1->ActivePage== TabSheet2)

DataModule1->Table2->Filtered=false;



if (PageControl1->ActivePage== TabSheet3)

DataModule1->Table3->Filtered=false;

} 

}

//---------------------------------------------------------------------------

void __fastcall TZAGS::AZapros1Execute(TObject *Sender)

{

Zapros1->Panel1->Visible=true;

Zapros1->Show();

}

//---------------------------------------------------------------------------

void __fastcall TZAGS::AZapros2Execute(TObject *Sender)

{

Zapros1->Panel2->Visible=true;

Zapros1->Show();

}

//---------------------------------------------------------------------------

Размещено на Allbest.ru
								