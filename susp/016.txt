Groovy — объектно-ориентированный язык программирования, созданный для работы с  Java-платформой в качестве дополнения к языку Java с возможностями Ruby, Python и Smalltalk.
Groovy использует Java-подобный синтаксис с динамической компиляцией в JVM байт-код. Groovz также напрямую работает с другим Java кодом и библиотеками.
В Java Community Process JSR 241. завершён процесс стандартизации языка Groovy.
Язык может использоваться как скриптовый язык, а вообще, и в любом Java-проекте.
Первым упоминанием о Groovy было в сообщение в блоге Джеймса Стрэчена в августе 2003 г.
Позднее, между 2004 и 2006 годами, было выпущено несколько версий.  
 Нумерация версий была изменена после того, как начался процесс стандартизации JCP, версию называют «1.0». Версия «1.0» была выпущена 2 января 2007 года.
В декабре 2007 года вышел Groovy 1.1. Вскоре эта версия  была перенумерована как «1.5» вследствие значительных изменений в языке.
Стрэчен покинул проект за год до релиза Groovy 1.0 , в июле 2009 года он написал в блоге, что не создал бы Groovy, если бы в 2003 году прочитал книгу Одерского с соавторами о программировании на Scala.
Главой проекта разработки языка и комитета JSR-241 с 2007 года  является Гийом Лафорж (Guillaume Laforge).
Последние версии генератора отчётов iReport основаны на Java-библиотеке JasperReports. Они позволяют встраивать в отчёты выражения на Groovy и писать на нём дополнительную логику.
В Java есть система непрерывной интеграции Hudson. Она позволяет использовать сценарии автоматизации, созданные на Groovy.
Groovlets — возможность запускать скрипты на Groovy как сервлеты.
Если Groovy содержит код вне определения класса или класс с методом main или Runnable или GroovyTestCase, то исходный код в там может быть выполнен как обычный скрипт, в отличие от Java.
Groovy неявно генерирует методы для доступа к переменным (setColor(String color) и getColor()):
Groovy предлагает простой и последовательный доступ к спискам, отображениям и массивам:
Closure (замыкание) — это анонимная функция и объект в одном виде:
return в функции указывать не обязательно — по умолчанию будет возвращено значение последней упомянутой переменной.
Неизменяемые классы маркируются с помощью аннотации Immutable:
Сопоставление способностей Groovy с разными языками см. в посте Сравнение языков программирования
Groovy — объектно-ориентированный язык программирования. Он был разработан для платформы Java как альтернатива языку Java с возможностями Python, Ruby и Smalltalk.
Groovy работает с Java-подобным синтаксисом с динамическим преобразованием в JVM-код и напрямик использует  другие Java коды и библиотеи.
Язык может использоваться в любом Java проекте. Groovy также можно использовать как скриптовый язык.
Почти всегда java-код - валидный groovy-код.
Для установки нужно скачать архив с оф. сайта , распаковать его в удобное место и добавить переменyю окружения GROOVY_HOME. Не забудьте добавить путь до groovy/bin в PATH!
В IDE NetBeans 7.0 поддержка groovy идет из коробки. А вот для IDE Eclipse существует очень хороший плагин, его можно взять здесь.
Самым важным отличием от java является то, что в Groovy всё считается объектами.
Абсолютно все примитивные типы  в Groovy сразу же упаковываются в объекты. Т.е. «int x» на самом деле является полноценным объектом «Integer x»
Следует не забывать о том, что все упаковочные типы — неизменяемые. Так, каждый раз при каком-либо вычислении будет создаваться новый объект.
В строках groovy можно вставлять параметры, в обычные строки — нельзя
К строкам применимы ++ и - —.
В groovy  на уровне конструкций языка возможна поодержка регулярных выражений.
Так же на уровне конструкций языка поддерживаются словари (maps) и списки:
Есть несколько способов получать доступ к элементам списков в groovy. Один из них:
Range — это такой же объект, поэтому возможны конструции, подобные последней.
Отрицательные индексы объектов так же, как и в языке программирования python, возвращают элементы, начиная с конца списка.
Более того, range можно сделать из любого объекта, у которого есть методы next() и prev().
Циклы в groovy точно такие же, как и в java, хотя есть и один дополнительный - «foreach»:
Ключевое слово return указывать не обязательно. В отличие от других языков, здесь по умолчанию будет возвращено значение последней упомянутой переменной в фукции.
У многих объектов языков программирования такого типа есть методы, в качестве параметров которым можно передать closure:
Доступно большое количество методов для обработки последовательностей. К ним также можно применять замыкания:
В closure так же не обязательно использовать ключевое слово return.
Если явно не задано имя параметру, то по умолчанию используется it.
Так как closure является объектом, то ничего не мешает возвращать его из другого closure, и таким образом создавать функции высших порядков:
Для директорий есть функции eachFile и eachFileRecursive:
Для обработки файлов функция eachLine.
Писать в файлы очень удобно.
Неизменяемые классы задаются с помощью Immutable.
При использовании этой аннотации нужно указывать, какого типа поле.
Проверяет переменную a, и если в ней null или false, то берет указанное значение,  иначе берется значение a.
Вернет null, если если в user содержится null.
В Groovy можно перегружать операторы.
Для этого нужно определить метод. 
Для перегрузки оператора ++ нужно переопределить next():
Оператор "==" уже перегружен для всех объектов.
Полный список методов, доступен здесь: http://groovy.codehaus.org/Operator+Overloading.
SQL обрабатываются просто.
В groovy существуют специальные билдеры, которые можно использовать для генерации XML документов.
Для генерации создается экземпляр объекта MarkupBuilder, на котором вызываются псевдо-методы.
В качестве параметра конструктору MarkupBuilder можно передавать PrintWriter.
С помощью GroovyServlet возможно запускать скрипты на Groovy.
Для этого нужно добавить несколько строчек в web.xml:
Все запросы будут обрабатываться классом GroovyServlet.
В скриптах доступны для использования переменные.
Отдаст браузеру правильно сгенерированную html-страницу.
Groovy —  язык программирования, разработанный для Java.
Язык призван дополнить возможности Java элементами.
Программы, написанные на Java, являются программами на Groovy.
Последний обладает более лаконичным синтаксисом и большими способностями.
К этому времени относятся первые упоминания в блоге James Strachan. 
Стандартизация Java Community Process началась позднее, и первая версия языка 1.0 была выпущена 2 января 2007 года.
 Java нет типа данных для работы с комплексными числами, поэтому вычисления производятся в дробных числах.
Данная реализация позволяет решать сложные квадратные уравнения не только с целыми, но и с дробными коэффициентами.
Данные коэффициенты читаются из потока System.in.
Напрямую из него можно читать только отдельные байты, поэтому для чтения используются InputStreamReader и BufferedReader.
Строки, прочитанные из System.in, преобразуются в числа с помощью Double.parseDouble().
Все операции ввода в языке программирования Java должны находиться внутри блоков обработки try ... catch, чтобы гарантированно обрабатывать IOException — класс исключений, порождаемых функциями чтения.
Для языка Java приведенный ниже код должен находиться в файле HelloWorld.java.
В этом примере используется рекурсивное определение факториала.
Для хранения в оперативной памяти больших чисел использован элементарный тип данных long, позволяющий хранить числа от -263 до 263-1.
В этом примере используется рекурсивное определение чисел Фибоначчи.
В этом примере используется итеративное вычисление факториала.
Для хранения в оперативной памяти компьютера больших чисел используется встроенный класс BigInteger, позволяющий обрабатывать сколь угодно большие числа ценой увеличения времени обработки.
В этом примере используются регулярные выражения языка программирования Java.
В данном примере регулярное выражение [a-zA-Z]+ описывает последовательность букв латинского алфавита в любом регистре, идущих подряд, окруженную другими символами или концами строки.
Классы pattern и matcher дают возможность создать это регулярное выражение и вычленить из строки все фрагменты, совпадающие с этим регулярным выражением.
Первый символ каждого такого объекта переводится в верхний регистр, а последующие символы  в нижний, с использованием стандартных методов класса String.
Результаты обработки записываются в переменную типа StringBuffer, накапливающую результат.
В этом примере используется итеративное определение факториала: для вычисления факториала числа единица умножается последовательно на все числа от 1 до этого числа.
В этом примере используется рекурсивное определение факториала.
Чтобы данная функция могла обращаться сама к себе рекурсивно, необходимо, чтобы она имела специальное объявление перед осуществлением. 
Если тип значения, не задан, то используется целочисленный, и при вычислении 13! возникает переполнение целого.
В данном примере используется простейшее рекурсивное определение чисел Фибоначчи.
С выходом версии парсера, совместимой с JSR-241 изменения в синтаксисе Groovy были формализованы. Это означает, что если раньше вы не уделяли этому внимания, то теперь самое время начать это делать.
В этом месяце специалист по Groovy Эндрю Гловер проходит по наиболее важным изменениям в Groovy и демонстрирует функцию, которой нет в классическом языке Groovy.
Почти год прошел с того дня, когда я познакомил вас с Groovy в статье "Feeling Groovy".
С тех пор Groovy сильно изменился и претерпел несколько релизов, в которых постепенно решались задачи реализации языка и удовлетворялись потребности в функциональности, имеющиеся у сообщества программистов.
И, наконец, Groovy сделал гигантский шаг вперед в апреле этого года. После того как вышла новая официальная версия парсера, нацеленная на стандартизацию языка в части обработки JSR
За этот месяц я отпраздновал рост Groovy, представил наиболее важные изменения, формализуемые новым отличным парсером Groovy; а именно объявление переменных и closures.
Я буду сравнивать новый синтаксис Groovy с классическим синтаксисом, откройте в другом окне браузера статью "Feeling Groovy".
Если вы следили за Groovy некоторое время, то вы могли найти в языке пару багов.
Если дело доходит до сложных операций, Groovy начинает страдать от встречающейся временами двусмысленности и определенных ограничений синтаксиса.
Несколько месяцев назад команда Groovy начала работу по исправлению этих багов.
В новой версии был обновлен синтаксис, а также был представлен парсер, "знающий" этот синтаксис, для его стандартизации.
Хорошая новость состоит в том, что в новом синтаксисе языка Groovy реализовано множество усовершенствований.
Очень хорошей новостью стало то, что новая версия языка Groovy не отличается от старой версии.
Синтаксис новой версии языка был разработан для скорейшего его изучения и максимальной отдаче.
С появление нового парсера часть синтаксиса стала несовместимой с новой версией языка.
Вы увидите это, если попробуете запустить примеры кода из предыдущих статей этой серии с новым парсером, возможно, что они не будут работать! 
Задача новой версии парсера состоит в том, чтобы популяризовать язык Groovy.
Я уверен что эта экскурсия по Groovy будет полезна.
Я перечислю несколько неизмененных вещей, прежде чем вдаваться в подробное описание изменений.
Динамическая типизация не подверглась изменению в новой версии.
Необязательной осталась явная типизация переменных, например типов String или Collection
Я объясню дополнение к этому правилу в следующей статье.
Многие испытают огромное облегчение от того, что точки с запятой также остаются необязательными разделителями.
Было много разных аргументов в пользу динамической типизации, но в конце концов победило мнение "лучше меньше, да лучше". 
В итоге, для тех, кто использует в качестве разделителя точку с запятой, такая возможность осталась.
Коллекции не претерпели  изменений.
Вы по-прежнему можете объявлять коллекции типа list, используя синтаксис array и map так же, как и раньше. Научиться этому вы можете в другой статье.
С другой стороны, диапазоны значений слегка изменились, и вскоре я покажу, как именно они изменились.
И, наконец, дополнения Groovy к стандартным классам Java Development Kit не изменились совсем.
Синтаксис языка и интерфейсы API остались прежними, как и обычные типы Java File, о которых я расскажу позже в следующих статьях.
Вероятно, с последующим введением нового синтаксиса языка, совместимого с JSR, наибольший удар пришелся на долю тех правил работы, которые имели дело с переменными в языке Groovy.
Классический Groovy был очень гибким в отношении объявления переменных.
В новой версии JSR Groovy до каждой переменной нужно указывать ключевое слово def или   модификатор, типа private, protected или public. 
Вы всегда можете указать тип переменной и ее значение.
Если вы определяете класс и хотите объявить свойства и их значения, вы можете объявить поля, указав ключевое слово @Property. 
Буква P в слове Property заглавная, нужно писать ее с большой буквы!
Когда я представлял вам GroovyBeans в посте "Feeling Groovy" в листинге 22 настоящей статьи,  я объявлял тип данных  LavaLamp. 
Он больше не совместим с JSR. Если вы попытаетесь запустить парсер, он вернет ошибку.
К счастью, выполнить перенос класса не так сложно, нужно добавить атрибут @Property ко всем нужным переменным, как видно из приведенного ниже листинга 1.
Как было подробно описано выше и будет повторено ниже, ключевое слово def необходимо для объявления любой переменной, у которой нет иного модификатора, ключевого слова формата @Property или другого поддерживаемого типа. 
Например, в коде Groovy, приведенном в листинге 2, в методе toString содержится ошибочно определенная переменная с именем numstr, наличие которой совершенно точно приведет к возникновению  ошибки, которая может оказаться критической при попытке запуска парсера JSR.
Этот код позаимствован из листинга 1 статьи "Stir some Groovy into your Java apps."
В листинге 3 вы можете увидеть нехорошее сообщение об ошибке, которое появится в том случае, если вы попытаетесь запустить этот код без изменений.
Решение, конечно же, состоит в добавлении ключевого слова def к numstr в методе toString, это решение показано ниже.
Также я мог указать модификатор numstr, например private, или объявить его как StringBuffer, в JSR Groovy я должен указать перед названием переменной хотя бы что-нибудь.
Синтаксис closures сильно изменился, но большей частью только в отношении определения параметров.
Если в классическом языке Groovy вам нужно определить параметр closure, в качестве разделителя нужно использовать символ |.
Символ | нельзя было использовать в Groovy, за исключением контекста объявления параметров closure, поскольку, как вы, наверное, знаете, этот символ является побитовым оператором в обычном языке Java.
К сожалению, мое знакомство с языком Groovy не было удачным.
Обнаружилась невысокая производительность языка Groovy, и отсутствие масштабных плюсов по сравнению с Java.
Единственный плюс, который я видел в Groovy, его отладочная консоль сервера.
Наш сервер работает на JavaScript от Mozilla, ещё с тех далёких пор, когда его не существовало в JRE.
Однако позднее пришлось доделывать проект, написанный на Groovy, и тогда в этот язык мне очень понравился.
Нужно часами придумывать, как сделать рефакторинг Java кода, чтобы он стал более читаемым, более производительным, более грамотно организованным.
Но на Groovy можно зайти ещё дальше, есть интересный пример, как программу на Java, можно переписать.
Первое и самое главное достоинство Groovy состоит в том, что программа на Java - это программа на Groovy.
Вовсе необязательно переписывать код, ведь все библиотеки Java, написанные за последние ≈15 лет, можно использовать и в Groovy.
