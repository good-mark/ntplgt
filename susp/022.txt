В противовес централизованным системам контроля версий, распределённая натура Git'а позволяет вам быть гораздо более гибким в отношении роли создателей в разработке проекта.
В централизованных системах все разработчики считаются узлами сети, наиболее либо наименее идиентично работающими на центральном хабе.
Тем не менее, в Git'е любой создатель потенциально считается и узлом, и хабом.
То есть каждый из создателей может и вносить код в другие репозитории, и содержать публичный репозиторий, на базе которого действуют остальные разработчики, и в который каждый из них вносит собственные конфигурации.
Это даёт вашему коллективу возможность применять хоть какой из большого количества разных методик осуществления рабочего процесса в ваших проектах, потому мы осмотрим некоторое количество популярных подходов, пользующихся гибкостью Git'а.
"Мы рассмотрим как удачные качества, так и вероятные недочеты всякого подхода; вы сможете выбрать для себя один, а можете совместить особенности сразу нескольких подходов.
"
В централизованных системах обычно есть 1 способ общего исследования — централизованный рабочий процесс.
Единственный основной хаб, по-другому — репозиторий, способен получать код, все остальные просто синхронизируют свою работу с ним.
Часть разработчиков считаются узлами — так называемыми клиентами данного хаба — и синхронизируются только с ним (смотри Рисунок 5-1).
Это означает, что если 2 разработчика выполняют клонирование с хаба и оба меняют что-то в проекте, то 1-ый выславший собственные конфигурации назад, сможет сделать это без проблем.
Второй разработчик должен взять наработки первого и выполнить слияние перед тем, как отправить свои изменения, так чтобы не перезаписать изменения первого разработчика, такой  принцип справедлив для Git'а точно так же, как и для Subversion (или любой другой ЦСКВ), и в Git'е такая модель работает отлично.

Если у вас небольшая команда или вас полностью устраивает рабочий процесс централизованного типа, применяемый в вашей компании, вы можете просто продолжить использовать такой рабочий процесс и в Git'е, просто настройте один репозиторий и дайте каждому в вашей команде права на отправку изменений; Git не позволит пользователям перезаписывать наработки друг друга.
Если какой-то разработчик склонирует репозиторий. После, сделает в нём изменения, а затем попытается выложить эти изменения, в то время как другой разработчик уже успел отправить свои, сервер отклонит изменения этого разработчика. 
Ему будет сказано, что он пытается выложить изменения, для которых невозможно выполнить перемотку (fast-forward). Также, что надо сначала извлечь данные с сервера, выполнить слияние, а уже потом отправлять свои изменения.
Такой рабочий процесс привлекателен для большого количества людей, так как это та модель, с которой многие знакомы .
Git позволяет иметь несколько удалённых репозиториев, существует возможность ведения такого рабочего процесса, при котором каждый разработчик имеет права на запись в свой собственный публичный репозиторий.
Этот сценарий подразумевает существование канонического репозитория, который представляет "официальный" проект.
Чтобы принять участие в работе над проектом, надо создать свою собственную  копию проекта и выложить  свои изменения. 
Вы можете отправить запрос владельцу проекта на внесение в него изменений.
Он может добавить репозиторий в качестве удалённого, протестировать ваши изменения, слить их со своей веткой и затем отправить обратно.
Этот процесс осуществляется следующим очень простым способом образом (см. Рис. 5-2).
Владелец открытого проекта выкладывает файлы в публичный репозиторий на сайте Github.
Участники проекта клонируют этот репозиторий на локальную машину  и делают изменения.
Затем, участники выкладывают изменения в свои собственные публичные репозитории на Гитхабе.
Участник проекта отправляет владельцу письмо с просьбой включения его изменений в свой основной репозиторий .
Владелец проекта добавляет репозиторий участника как удалённый и локально выполняет слияние, хотя конечно же может этого и не делать.
Это очень распространённый тип рабочего процесса для сайтов вроде GitHub, где можно легко форкнуть проект и выложить свои изменения на всеобщее обозрение в собственную копию.
Одно из главных преимуществ такого подхода — возможность продолжать работать, в то время как владелец основного репозитория может включить себе ваши изменения, когда ему угодно. 
Участникам проекта не придётся ждать включения своих изменений в проект — каждый может работать в своём собственном ритме.
Это одна из разновидностей рабочего процесса с множеством репозиториев.
В основном он используется в огромных проектах с сотнями участников; ядро Linux — яркий тому пример. Несколько менеджеров по интеграции заведуют разными частями репозитория; этих людей называют помощниками.
Ты просто-напросто недолюбливаешь Git?
Ты абсолютно счастлив с Mercurial (или, фу, с Subversion), однако раз в месяц тебе приходится смело сталкиваться с Git, потому что каждый, в том числе и его чертова собака, ныне употребляет GitHub?
Тебя мучают неясные недоверия, будто половина всех команд Git на самом деле удалят всю твою работу совсем, однако ты никак не знаешь какие именно и не хочешь проводить 3 недели, углубляясь в документацию?
Отличные новости!
Я написал тебе данный удивительный Веб-пост.
Надеюсь, я смогу впихнуть в тебя достаточно много Git-а, чтоб снизить возможность изготовить что-то непоправимое, а так же убавить твой ужас испортить что-нибудь.
Этого должно быть еще довольно, чтоб изготовить документацию Git немного более понятной; она очень кропотливо и углубленно продумана и будет совсем тупо, если ты до сих пор не прочел половину.
Я стараюсь объяснять кратко, однако также, чтоб принести пользу людям, кто совсем ни разу не встречался с контролем версий, потому всюду будет размещен сто один совет.
Мне не кажется, будто юзеры Mercurial не знают, что из себя предтавляет патч.
Что тут вообще проистекает, я никак не поймк?
Git — это DVCS, либо «распределенная система контроля версий», где «система контролирования версий» значит «запоминает историю твоих файлов», а «распределенная» значит «ты имеешь возможность делать это оффлайн». (Ранее фиксирование конфигураций вызывало безотлагательную загрузку твоих конфигураций на основной сервер.
Ты не мог сохранить код, если не мог подключиться к серверу. Верно?)
Git был изобретен Линусом Торвальдсом. Злобным мужиком, который также принес нам ядро Linux.
Linux — это огромный проект с очень длинной историей и он перерос VCS, которую использовал, поэтому Линус решил написать новую..
Процесс разработки Linux — это такой процесс, который ты бы вполне мог ожидать от группы людей, работающих над ядром Linux..
(Патч — это  текстовый файл, который перечисляет изменения между двумя версиями каких-то файлов. Ты можешь применить патч к старой версии.)
Итак, у Линуса есть «каноничная» копия  базы, которую ты можешь называть «репозиторий», это место для хранения данных.
Время от времени ты можешь скачивать свежую копию и приступать к написанию каких-нибудь сломанных Wi-Fi-драйверов или еще чего-нибудь.
Поэтому ты генерируешь патч отправляешь его в рассылку, а кто-то говорит «по-моему неплохо» и Линус применяет этот патч к его копии базы.
Теперь каждый, кто собирается работать с этим кодом, увидит там и твою работу тоже, но сохраненную на копии.
Самый великий секрет к пониманию Git, который, я надеюсь, заставит широко раскрыться твои глаза и прозвучать «ааа» из твоего рта, заключается в следующем небольшом и очень простом определении.
Git — это просто набор инструментов и вспомагательных конструкций  для рассылки патчей по почте.
Есть всего где-то пять или шесть  команд внутри поставки Git для этих определенных  простых целей. 
Есть даже подразделы в документации по командам гита: am, apply, format-patch, send-email, request-pull и тд..
Ты можешь прямо сейчас пойти в почтовую рассылку ядра Linux и увидеть своими глазами, что до сих пор все так и делается, Git просто делает большую часть очень скучной работы вместо программиста .
Git описывает Git, как «тупой трекер содержимого».
Git — это коллекция специализированных инструментов для решения конкретных проблем, которые тебе не хочется решать в одиночку.
Далее будем рассматривать Git, помня об этом.
 Важно знать, что патч представляет различия между двумя наборами файлов. 
Eсли в присланном по почте патче не указано явно к чему должен быть применен этот патч, то он просто бесполезен.
Работа с Git в отсутствии использования локальных ветвей из песочницы.
Прочтя еще одну статью про Git, я просто не имел возможность не обрисовать свой подход к решению вопроса, не рассчитывающий на необыкновенную оригинальность.
Я весь последний год удачно пользуюсь гитом, творя минимальное колличество локальных веток.
Не стану настаивать, будто так работать верно либо неверно — по-просту делюсь экспириенсом.
А всех, кому любопытно «как» — прошу под кат.
Я даже не пробовал убирать или переводить на наш язык принятые в нашем кругу слова, такие как «закоммитить», форк, «staged» файлы или pull request (неужели хоть кто-то читает git man не на английском?).
Мне известно, что Git имеет возможность употребляться в отсутствии центрального сервера, однако в моём случае (и чаще всего) в планах имеется GitHub, BitBucket либо их аналоги.
Возможно, данная статья никак не нацелена на знакомящихся с Git.
Дело в том, что в авторе упомянутой заметки я узнал себя: как-то раз меня достало количество локальных ветвей, лежащих в моей копии.
Легко перенести локальные изменения поверх того, что есть в удалённом аналоге, набрав git pull [--rebase], но у вас ведь могут быть еще незакоммиченные изменения (как в index/stage, так и not staged файлы).
Начнём с  первого вопроса: какие функции выполняет локальная ветка?
Она чаще всего лишь отслеживает удалённый аналог, (с таким же именем или нет — не важно). При этом постоянно с ним синхронизируясь.
Вам надо: сохранить неотправленные на сервер коммиты и сохранить незакоммиченные файлы.  Возможно отделив staged от not staged, возможно, даже разбив эти файлы на 3-5 разных версий изменений.

Мы обычно используем git stash, создаём локальные ветки, что снова увеличивает их количество.
Наша оригинальная ветка осталась привязана к удалённой, но новосозданные ветки потеряли это преимущество — нужно учить синтаксис.
Как часто мы делаем git push не HEAD состояния (кроме случаев с тегами)?
Что  полезного несёт локальная ветка в отличии от локального коммита? 
А у кого была ошибка «There is no tracking information for the current branch» при git pull?
Приходится вспоминать команду привязывания локальной ветки к удаленной .
А если мою локальную ветку надо связать с двумя раздельными репозиториями на локальной машине?
А еще при команде git merge b надо помнить, совпадает ли у тебя b с origin/b — не лучше ли сразу делать git merge origin/b, так не будет конфликтов.
«Но у меня есть ветки, не привязанные к удалённым веткам на сервере!»
Когда я вообще в последний раз работал с этой  не привязанной веткой?
Когда она будет отправлена в удалённый репозиторий ?
Почему эта ветка сейчас не отправлена в удаленный репозиторий на сервере?
Я работаю над несколькими проектами одновременно. 
Но в каждом проекте над одной задачей.
 Поэтому в HEAD у меня обычно находится код для решения той самой задачи.
Только если возникает необходимость отложить задачу на какое-то время, то я делаю отдельную локальную ветку, при этом не заливаю ее на сервер.
В настоящее время большая часть проектов с открытым исходным кодом, а еще огромное количество корпоративных проектов, употребляют Subversion для управления собственным исходным кодом.
Это исключительно знаменитая на нынешний момент система контроля версий с открытым исходным кодом, история ее применения насчитывает около 10 лет.
Не считая такого, она совсем схожа на CVS, систему, которая была лично знаменитой до Subversion.
Одна из восхитительных особенностей Git'а — вероятность двустороннего размена с Subversion через интерфейс, именуемый git svn.
Данный инструмент позволяет применять Git в качестве корректного клиента при труде с сервером Subversion.
Так что вы сможете воспользоваться всеми локальными способностями Git'а, а потом беречь конфигурации на сервере Subversion так, как если бы использовали Subversion локально.
Таким образом вы делаете локальное разветвление и соединение, применяете индекс, смещение и подбор патчей для перемещения между ветками (cherry-picking) и т.д., в то время как ваши соперники продолжат применять в разработке подход времён каменного века.
Это неплохой метод протащить Git в рабочую среду собственной фирмы и посодействовать сослуживцам разработчикам начинать наиболее эффективными, в то время как вы будете педалировать окончательный переход на Git.
Интерфейс мены использующий Subversion — это кратчайший путь к распределённым системам контролирования версий.
Основной командой в Git'е для каждой команды, использующей мост к Subversion, считается git svn.
Ей предваряется любая команда, она принимает довольно порядочное число команд, поэтому мы изучим из них те, которые наиболее часто используются, рассмотрев несколько небольших вариантов работы.
Важно отметить, что при использовании git svn вы взаимодействуете с Subversion — системой, которая намного менее «продвинута», чем Git, хоть вы и умеете с лёгкостью делать локальное ветвление и слияние, как правило, лучше всего держать свою историю в как можно более линейном виде, используя перемещения (rebase) и избегая таких вещей, как одновременный обмен с удалённым Git-репозиторием.
Не переписывайте свою историю. Попробуйте отправить изменения ещё раз, а также не отправляйте изменения в параллельный Git-репозиторий, используемый для совместной работы, одновременно с другими разработчиками, использующими Git. 
Subversion может иметь только одну единственную линейную историю изменений. Сбить её с толку очень и очень просто. 
Если вы работаете в команде, в которой разработчики используют Git, а другие Subversion, убедитесь, что для совместной работы все используют только SVN-сервер.
Для того чтобы попробовать  функционал в действии, вам понадобится доступ с правами на запись.
Если вы хотите повторить примеры, вам нужно сделать доступную на запись копию. 
Это можно сделать с помощью утилиты svnsync, входящей в состав последних версий Subversion (после версии 1.4).
Для этих примеров я создал новый Subversion-репозиторий на Google Code, который был  копией проекта protobuf (утилита кодирования структурированных данных).
Чтобы мы могли продолжить, создайте локальный репозиторий Subversion.
Хотя выполнение этой  казалось бы простой операции и может занять всего несколько минут, однако, если вы попробуете скопировать исходный репозиторий в другой удалённый репозиторий, а не в локальный репозиторий , то процесс займёт почти целый час, хотя в этом проекте менее ста коммитов.
Subversion вынужден клонировать ревизии по одной за раз, а затем отправлять их в другой репозиторий — это чудовищно неэффективно и неудобно, однако это единственный простой способ выполнить это необходимое действие.
Теперь, когда в вашем распоряжении имеется SVN-репозиторий, для которого вы имеете право на запись и на чтение, давайте выполним типичные действия по работе с системой контроля версий. 
Начнём с  уже знакомой нам команды git svn clone, которая импортирует весь SVN-репозиторий в локальный Git-репозиторий.
Эта команда эквивалентна выполнению для указанного вами URL двух  также знакомых нам команд — git svn init, а затем  выполняем git svn fetch.
Процесс может занять некоторое время, от 10 до 50 минут.
В тестовом проекте всего около 75 коммитов, и кода там мало, поэтому, ждать  придется недолго. 
Однако, Git должен выполнить коммит для каждой версии.
Для больших проектов, с сотнями и тысячами коммитов, этот процесс занимает от нескольких часов до нескольких дней.
Опции -T trunk -b branches -t tags служат для того, чтобы сообщить Git'у, что SVN-репозиторий использует стандартные соглашения об именовании веток и тэгов.
Если вы часто применяете Git, то вам могут быть полезны фактические рекомендации из данной статьи.
Если вы еще начинающий, то начала вам выгоднее познакомиться с Git Cheat Sheet.
К примеру так, предоставленная статья специализирована для тех, у кого имеется опыт применения Git от 3-х месяцев. Осторожно: траффик, огромные рисунки!
Скорее всего, вам уже приходилось применять команду git log.
У неё имеется немало нужных характеристик, которые разрешено сочетать друг с другом для достижения лучшего итога.
К примеру, когда-то у меня был управляющий, который требовал недельные доклады каждую пятницу.
Мне хватило составить git log --author="Alex Kras" --after="1 week ago" --oneline, незначительно подправить результат и выслать их руководству.
Вообщем, в Git имеется немало всяких нужных характеристик.
Элементарно попытайтесь исполнить man git-log чтоб посмотреть все варианты просмотра летописи.
Если ни одно из предложенных решений вам не понравится, вы в любое время сможете пользоваться параметром --pretty, с поддержкою которого разрешено налаживать выдачу в широких пределах.
С помощью команд git log -p или git log -p filename можно посмотреть не только примечание к коммиту, автора и дату, но также сделанные в этом коммите изменения, а далее можно использовать функцию поиска утилиты less, набрав «слеш» и введя поисковый запрос: /{{поисковый-запрос}} (используйте маленькую "n" для перехода к следующему результату поиска и большую "N" для того, чтобы вернуться к предыдущему).
С помощью команды git blame filename можно определить автора последних изменений для каждой строки в файле, и это замечательный инструмент, однако иногда бывает недостаточно информации, которую он предоставляет.
В качестве альтернативы можно использовать команду git log с флагом -L.  Он позволяет указать номер интересующей строки в нужном файле, и Git отобразит только те изменения, которые связаны с этой строкой.

По сути это аналог команды git log -p. Вот только с фокусом на конкретных изменениях.
Если вам приходилось работать с долгоживущими ветками, над которыми трудится много людей, то вы наверняка сталкивались с множественными вливаниями родительской ветки  в ветку.
Мёржи затрудняют просмотр истории изменений рабочей ветки, потому что сложно отличить коммиты, родительской веткb от коммитов рабочей ветки.
Чтобы посмотреть изменения которые были в них внесены, можно использовать команды git show --no-merges master.. или git log -p --no-merges master.. (их вывод будет идентичным).
Иногда удобно посмотреть файл в другой ветке, не переключаясь на неё.
Это можно сделать с помощью git show some-branch-name:some-file-name.js, которая выведет содержимое файла в указанной ветке .
А с помощью перенаправления вывода можно сохранить этот файл в указанное место, если вы заходите открыть два файла одновременно: git show some-branch-name:some-file-name.js > deleteme.js.

Примечание: если вам нужно всего лишь сравнить два файла, то всегда можно выполнить такую не самую сложную команду: git diff some-branch some-filename.js.
Ранее мы говорили о многочисленных мёржах мастера в рабочую ветку репозитория проекта. 
Некоторых из них можно избежать без последствий, используя команду git rebase.
Вообще, ребейз — это очень мощная функция и сильная функция, пожалуй, будет лучше оставить её подробное описание для совсем отдельного поста.
Никогда не делайте ребейз коммитов, находящиеся вне вашего репозитория.
Если вы последуете этому совету, то всё будет хорошо с вашими нервами.
В противном случае все будут вас ненавидеть, а друзья и семья станут вас презирать.

Однако ребейза не нужно бояться, просто следует соблюдать осторожность при работе с ним.
Пожалуй, лучший способ сделать ребейз — использовать его интерактивный режим, запускаемый с помощью команды git rebase -i {{some commit hash}}, которая откроет редактор с инструкциями о том, что и как делать.
Не буду дальше вдаваться в подробности, поскольку тема эта достаточно объёмная.
Например, вы работаете с локальной копией ветки и сделали небольшой коммит.
А в это время кто-то ещё залил в удалённую копию ветки результаты своего недельного труда. Когда вы попытаетесь запушить свои изменения, Git скажет вам, что он не может это сделать, и что вам сначала нужно сделать git pull для разрешения конфликта.
Как добропорядочный человек вы так и поступите и после выполнения команды git pull в истории вашей локальной копии ветки получится вот такой вот коммит, сгенерированный автоматически: «Merge remote-tracking branch 'origin/master'».
