Hibernate — библиотека для Java, предназначенная для решения задач объектно-реляционного отображения.
Эта библиотека представляет собой свободное программное обеспечение с открытым исходным кодом.
Библиотека предоставляет легкий в использовании каркас для отображения объектно-ориентированной модели данных в традиционные реляционные базы данных.
Цель библиотеки Hibernate – это освобождение разработчика от большого объёма достаточно низкоуровневого программирования по обеспечению хранения объектов в реляционной базе данных.
Разработчик может использовать Hibernate в процессе проектирования системы классов и таблиц «с нуля».
Hibernate не только решает задачу связи классов Java с таблицами базы данных, но и также предоставляет средства для автоматической генерации и обновления набора таблиц, построения запросов и обработки полученных данных и может значительно уменьшить время разработки.
Hibernate автоматизирует генерацию SQL-запросов и освобождает разработчика от ручной обработки результирующего набора данных и преобразования объектов.
Hibernate обеспечивает прозрачную поддержку сохранности данных для «POJO» (то есть для стандартных Java-объектов).
Для корректного поведения в некоторых приложениях требуется также уделить внимание стандартным методам Java equals() и hashCode().
Mapping (сопоставление, проецирование) Java-классов с таблицами БД осуществляется с помощью конфигурационных XML-файлов.
Hibernate может генерировать скелет исходного кода для классов длительного хранения.
При использовании всем известной аннотации - в этом нет никакой нужды.
Hibernate использует XML-файл или аннотации для поддержания схемы БД.
Насколько мне известно, обеспечиваются возможности по организации отношения между классами «один-ко-многим» и «многие-ко-многим». 
Hibernate также может управлять рефлексивными отношениями, где объект имеет связь «один-ко-многим» с другими экземплярами своего собственного типа данных.
Hibernate может показывать пользовательские настройки.
Если выбрать столбик свойства, можно переопределить тип по умолчанию на SQL.
Проецирование перечисляемого типа Java на поле БД.
Коллекции объектов классов, как правило, хранятся в стандартных контейнерах Java-объектов, таких, как вектор или двунаправленный список.
Поддерживаются обобщенные классы (Generics), введеные в Java 5, Hibernate может быть настроен на «ленивые» (отложенные) загрузки коллекций.
Отложенные загрузки включены по умолчанию, с 3-ей версии.
Связанные объекты могут быть настроены на каскадные операции, например, родительский класс, Album (музыкальный альбом), может быть настроен на каскадное сохранение и/или удаление своего потомка Track.
Это может сократить время разработки и обеспечить целостность, так как функция проверки изменения данных (dirty checking) позволяет избежать ненужной записи действий в базу данных, выполняя SQL-обновление только при изменении полей персистентных объектов.
Успех библиотеки Hibernate подтолкнул JCP к разработке спецификации JDO, ставшей одной из стандартных технологий ORM на платформе JavaEE, также Hibernate совместима с JSR-220/317 и предоставляет стандартные средства JPA.
Hibernate обеспечивает использование SQL-подобного языка Hibernate Query Language (HQL). HQL позволяет выполнять SQL-подобные запросы, записанные рядом с объектами данных Hibernate.
Запросы критериев предоставляются как Объектно-ориентированная альтернатива к HQL, что довольно удобно.
Hibernate может использоваться как в самостоятельных приложениях Java, так и в программах Java EE. Программы Java EE выполняются на сервере (например, сервлет или компоненты EJB).
К любым другим языкам программирования можно подключить Hibernate и пользоваться всеми его функциями.
Adobe интегрировал Hibernate в девятую версию ColdFusionс уровнем абстракции новых функций и синтаксиса, приложенных к CFML.
Hibernate это Java библиотека, предназначенная для решения задач объектно-реляционного отображения.
Данная библиотека предоставляет лёгкий в использовании каркас для отображения объектно-ориентированной модели данных.
Кратко ORM — это проецирование объектов какого-либо объектно-ориентированного языка в структуры реляционных БД. 
Именно объектов, таких, какие они есть, со всеми полями, значениями, отношениями и так далее, перечислять можно долго.
Hibernate значительно уменьшает время разработки  Java приложений, работающих с базами данных и заботится о связи Java классов с таблицами базы данных.
Давайте напишем небольшое приложение, использующее библиотеку Hibernate для хранения и обработки таблицы СУБД Oracle.
 Для начала нам нужно скачать Hibernate, на данный момент последняя версия была Hibernate 4.1 и работать мы будем именно с ней.
Если библиотека будет много весить, то скорей всего в нее добавлена документация и различные примеры использования.
Также нам понадобиться скачать и установить СУБД Oracle, в этом примере я буду использовать Oracle 10.2, но вы можете установить более новую версию, особой разницы не будет.
После установки Oracle создайте пользователя и базу данных с каким-нибудь именем.
В базе данных создадим простенькую табличку с тремя полями.
Аннотации используются для сопоставления классов Java приложения с таблицами базы данных.
Чтобы Hibernate знал, что данный класс является сущностью, то есть объекты данного класса мы будем хранить в базе данных, использованные здесь аннотации имеют следующий смысл.
Теперь создадим пакет util, а в нем класс HibernateUtil. Этот класс будет отвечать за обработку данного xml файла и установление соединения с нашей базой данных.
Теперь нам осталось разобраться со взаимодействием нашего приложения с базой данных, тогда для класса-сущности, определим интерфейс StudentDAO из пакета DAO, содержащий набор необходимых методов.
Теперь мы определяем реализацию этого интерфейса в классе SudentDAOImpl в пакете DAO.Impl:
Интуитивно тут все понятно, давайте создадим класс Factory в пакете DAO, к которому будем обращаться за нашими реализациями DAO, от которых и будем вызывать необходимые нам методы.
В предыдущей части мы рассмотрели простейший пример использования Hibernate, в второй части мы рассмотрим виды запросов к базе данных.
Запросы возвращают набор данных из базы данных, удовлетворяющих заданному условию, библиотека Hibernate предлагает три вида запросов к БД.
Объект Criteria создается с помощью метода createCriteria экземпляра класса Session:
SQL — это язык, применяемый для создания, модификации и управления данными в базах данных.
Hibernate позволяет выражать запросы на декларативном языке SQL, что является очень хорошей новостью для любителей этого языка.
Выглядеть это будет, приблизительно, следующим образом:
В первом случае с помощью query.setString мы указываем порядковый номер параметра.
Если значение типа Long, то будет setLong, если Date, то setDate и так далее.
Во втором случае имя параметра задано явно, поэтому значение задается параметру по имени.
Библиотека Hibernate позволяет производить актуальные запросы на HQL(The Hibernate Query Language — Язык запросов Hibernate), который во многом похож на язык SQL, лишь с той малой разницей, что является полностью объектно-ориентированным.
Если запрос с помощью SQL производился методом createSQLQuery, то в HQL будет просто createQuery, рассмотрим простой пример.
В общем говоря, язык HQL относительно сложен, но зато богат и дает очень много возможностей.
Мы рассматривали создание простейшей таблицы Student, используя Hibernate, а также рассмотрели возможности запросов к данной таблице.
Далее будут рассмотрены такие вопросы как соединение между собой нескольких таблиц при помощи аннотаций.
Для начала, помимо таблицы Student, давайте создадим еще две таблицы Test и Statistics, они будут связаны следующим образом.
SQL таблица Statistics служит для связи таблиц Student и Test, для того чтобы избежать отношения многие ко многим.
Классы TestDAO и TestDAOImpl создаются аналогично как для сущности Student, нужно только показать Hibernate, как эти таблицы между собой связаны.
Для решения этой задачи в Hibernate существует несколько видов аннотаций.
Как вы видите, в данном Java классе Student мы объявили атрибут типа Statistics и обозначили, что данная таблица связана отношением многие к одному с таблицей, представленной классом-сущностью Statistics.
А в классе Statistics указали связь один ко многим с классом Student.
Аннотации @JoinTable указывает, какое поле является внешним ключом к текущей таблице. 
Так же само мы обозначаем отношение таблицы Test и Statistics, просто добавив в класс Test код:
В классе Statistics аннотируем связь один ко многим с классом Test:
Поскольку таблица Statistics является не просто таблицей, связанной со Student и Test, а она разбивает нежелательную связь многие ко многим.
Просто вместо того, чтобы просто отдельно обозначать связь в каждой таблице, мы обозначим всю связь в одной, к примеру, в таблице Test добавив следующий занимательный код.
Мы рассмотрели как можно создать таблицы для хранения в базе данных с помощью Hibernate Framework. 
В этой статье мы узнали как можно связать эти таблицы между собой, а также познакомились с различными видами запросов к данным таблицам средствами Hibernate.
Далее рассмотрим вопросы управления и конфигурации Hibernate с помощью библиотеки Spring Framework.
С помощью библиотеки Spring мы настроим подключение к базе данных, а также научимся управлять транзакциями.
Создадим в Eclipse проект типа Maven Project и назовем его HibernateSpringExample.
В главной директории будет находится файл конфигурации pom.xml:
Зависимостей очень много, но Maven без труда их скачает и добавит к нашему проекту, тем самым облегчив разработку.
Особое внимание хочу обратить на последнюю зависимость - это jdbc драйвер для подключения к базе данных.
В репозиториях его скачать нельзя, поэтому, чтобы использовать его в этом проекте, мы должныего зарегистрировать.
Для этого скачиваем необходимый jdbc драйвер.
Через командную строку заходим в директорию, где находится наш драйвер, и выполняем команду:
Теперь в пакете ru.javaxblog.hibernateSpringExample директории main.java создадим интерфейс StudentDAO.
В котором опишем основные методы работы с нашей БД:
Hibernate - это объектно-реляционное управление памятью и стабильная основа, которая предоставляет множество дополнительных возможностей.
Операция преобразования классовой иерархии в модель реляционной базы данных - сложная задача.
Данная статья описывает три важные стратегии, которые можно применять при ежедневном программировании на Java для упрощенного преобразования моделей сложных объектов в модели реляционной базы данных и не только.
У библиотеки Hibernate есть ряд значительных преимуществ перед другими подобными подходами к объектно-реляционному управлению (JDO, компоненты управления данными, внутренняя разработка программ и т.д.): это крайне доступная исходная программа, достигшая высокой степени зрелости, она весьма широко используется между разработчиками и активно обсуждается в мире.
Чтобы интегрировать пакет Hibernate в существующий Java-проект, нужно пройти следующие, не очень трудозатратные, этапы.
Последняя версия библиотеки Hibernate доступна на официальном сайте.
Скопировать необходимые Hibernate-библиотеки (JAR-файлы) в свои CLASSPATH приложения.
Файлы конфигурации будут использоваться для преобразования Java-объектов в таблицы базы данных.
Скопировать файлы XML-конфигурации в свои CLASSPATH приложения.
Вы увидите, что вам не придется видоизменять ни один Java-объект для поддержки основы, что не может не радовать.
Представьте, например, что вам нужно изменить большую таблицу базы данных, которую использовало ваше Java-приложение - к примеру, переименовать столбец в таблице или строку. 
Все, что нужно сделать, чтобы модифицировать ваше Java-приложение (для изменения таблицы) - изменить соответствующий файл XML-конфигурации и больше ничего не нужно.
Hibernate предусматривает язык запросов, который называется Hibernate Query Language.
Тем из вас, кто предпочитает старые добрые SQL-запросы, библиотека Hibernate все еще дает возможность использовать их в программе.
Мы в своих примерах будем использовать исключительно HQL, для удобства и ясности.
HQL весьма прост в обращении.
Вы найдете все знакомые ключевые слова, известные вам по SQL.
HQL отличается от SQL тем, что вы не пишете запросы прямо в вашей модели данных.
Синтаксис HQL подробно описан на сайта Hibernate Website.
Суть функциональности Hibernate - это файлы XML-конфигурации, которые должны находиться в вашем CLASSPATH приложении.
Мы расположили их в справочнике нашего пакета с кодами-образцами, что вполне логично.
Первый файл, который мы рассмотрим - это hibernate.ctg.xml, этот файл содержит информацию, соответствующую вашему источнику данных, и отсылает к другим файлам конфигурации, которые будут содержать необходимую вам информацию о преобразовании.
Сохраненные XML-файлы позволяют преобразовывать Java-классы.
Важно отметить, что названия файлов создаются по образцу ClassName.hbm.xml.
Мы рассмотрим основной пример, который показывает, как библиотека Hibernate реализует три различные стратегии, которые позволяют использовать Hibernate для объектно-реляционного преобразования.
Наше очередное пробное Java приложение будет использоваться некой страховой компанией, которая должна сохранить все легальные записи с авторскими правами, что и гарантируется всем покупателям.
Эта исходная программа предусматривает основные функции, с помощью которых можно построить законченное приложение, как, например, Web- или Swing-приложения.
Образец предполагает классическое использование, подходящее для таких типов приложений .
Пользователь может обеспечить поисковый критерий для разных покупателей, а затем представить список всех покупателей, распределенных по особому критерию.
Пользователь может предоставить покупателю из этого списка возможность более детального обзора.
В нашем приложении авторские права представлены классом Right, этот класс может быть либо Lease (аренда), либо Property (собственность). 
Right - собственность покупателя, для обозначения нашего покупателя мы используем обобщенный класс Person. 
Person может быть либо Individual, либо Corporation.
Страховая компания должна знать Estate , к которой эти Rights приписываются. 
Estate - очень обобщенный элемент, согласитесь, поэтому мы будем использовать классы Land (земля) и Building (здание), чтобы предоставить нашим разработчикам более понятные термины для работы.
Наша небольшая модель базы данных была смоделирована так, чтобы описать три различные стратегии, которые мы обсудим в этой статье.
Для иерархии Right мы используем одну таблицу и преобразуем в нужный класс.
Hibernate поддерживает большое разнообразие RDBMS.
Тем не менее, код-образец и текст этой статьи приспособлены к HSQLDB (см. Resources). HSQLDB - это полнофункциональная реляционная база данных, полностью написанная на языке Java.
В SQL-справочнике вы найдете файл под названием datamodel.sql, этот SQL-текст создает модель данных, используемых в нашем образце.
Также всегда можно построить и выполнить код-образец, используя командную строку. Можно рассмотреть возможность установки проекта в IDE для лучшей интеграции.
Как следует убедитесь в том, что в ваш CLASSPATH приложения переесены все необходимые библиотеки.
Коду требуется только Hibernate- и HSQLDB-библиотеки.
В первой нашей стратегии мы посмотрим, как преобразовывать иерархию Person, это довольно занимательно.
Модель данных очень близка нашей классовой модели, поэтому мы будем использовать различные таблицы для каждого класса в иерархии, но все эти таблицы должны иметь один и тот же ключ.
Hibernate использует этот первоначальный ключ, когда в базу данных включаются новые записи, и он может также использовать этот же первоначальный ключ для выполнения JOIN-операций во время доступа в базу данных.
Сейчас нам нужно преобразовать нашу объектную иерархию.
В число самых известных ORM-фреймворков входит Hibernate.
Не нужно забывать и об отрицательных сторонах, главная из которых - производительность. 
Само собой, что работа с БД посредством грамотно написанного SQL-кода будет более производительной.
Hibernate создает запросы оптимизированные, в то время, как на SQL нужно грамотно написать запросы.
Так же у разработчиков уходит уйма времени на написание запросов и хранимых процедур.
Одной из привлекательных сторон библиотеки Hibernate есть то, что он поддерживает диалекты ко всем популярным системам управления базам данных.
Наши приложения становятся еще и СУБД-независимыми. Единственное, что придется поменять если мы хотим перейти на другую СУБД, - это диалект в конфигурации Hibernate.
Основная задача бибилотеки Hibernate – сделать так, чтобы разработчик думал в терминах объектов. 
Не просто на уровне таблиц – а на уровне отношений между.
Если тот же студент учится в группе, то связь должна быть на уровне объектов.
Загруженный объект “Студент” должен иметь ссылку на объект “Группа”.
Для получения данных о группе объект “Студент” не надо делать явный запрос к базе данных.
В коде на Java мы просто должны вызывать метод student.getGroup()
Все пакеты, похожие на Hibernate, предназначены именно для того, чтобы дать возможность программисту думать в терминах объектов и отношений между ними.
Отношения между объектами могут быть разных типов – один-ко-многим, один-к-одному, многие-ко-многим, многие-к-одному.
Разработчикам доступна возможность создавать иерархии классов.
Именно наследование, которое так вдохновляет поборников объекто-ориентированного программирования.
Не все абсолютно гладко, но в общем и целом достаточно прилично.
Поначалу все эти мелкие сложности библиотеки Hibernate покажутся чрезмерно излишними – ну в конце концов, что нам стоит написать несколько SQL-запросов на получение данных – добавление, запрос, исправление и удаление.
Сложные запросы, которые часто требуются для создания головоломных отчетов эффективнее сделать на SQL.
